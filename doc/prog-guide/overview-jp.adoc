== 基本

この章では、関数型言語とオブジェクト指向を
理解するのに必要となる、基本の概念と用語を説明します。
すでに分かっている人であれば、 読み飛ばしてもかまいません。


=== 関数型言語


==== 評価

```
人間：「３と４を足すといくつ？]
計算機：「７です]
```

計算機(computer)は
人間からの質問(question)に対して答え(answer)を返します。

image::compute.png[align="center"]

この処理を関数型言語では評価(evaluation)と呼び、
人間から受ける質問の事を文(statemennt)、
そして人間へ返す答えの事を作用(effect)と呼びます。

image::evaluate.png[align="center"]

ここで、文は式と宣言の二つに分類され、
作用は値と環境の二つに分類されます。

```
<評価(evaluation)> ::= <文> <作用> .

<文(statement)> ::= <式(expression)> | <宣言(declaration)> .

<作用(effect)> ::= <値(value)> | <環境(environment)> .
```

以下の実行例であれば、
「式 `3 + 4` を評価した結果は値 `7` である」
と解釈します。 

```
umu:1> 3 + 4
val it : Int = 7
```


==== 式と定数

式(expression)は多くの要素から構成される文の一種です。

```
<式(expression)> ::=
        <定数>
      | <変数>
      | <適用式>
      | <ラムダ式>
      | <分岐式>
   /* | .... etc */ .
```

その中から、最も単純な定数(constant)と演算子(operator)について
評価の方法を以下に示します。

* 定数: [例] `3`
. 定数が表す値を返します。
* 演算子: [例] `+`
. まずその被演算子(operand)を再帰的に評価し、
. その値を元に演算して結果の値を返します。

image::eval-const.png[align="center"]


==== 変数と環境

値には名前を付けることができます。
たとえば円周率を表すのに
毎回 `3.14159265358979` と書くのは
面倒ですからそれを `PI` と命名し、
その名前で円周率の値を表すものと解釈します。
ここで、

* 値に付けられた名前の事を変数(variable)、
* 名前と値との対応関係を「束縛(bind)」、
* 束縛が記録される辞書の事を環境(environment)

と呼びます。また、

* 名前を付ける、すなわち名前と値との対応関係を生む行為を
「(名前に値を)束縛する(bind)」、
* 環境へ新たな束縛を追加する行為を「(環境を)拡張する(extend)」

と表現します。

変数は以下のように評価されます。

* 変数の名前を環境(environment)から探し(lookup)、
. もし見つかれば束縛された値を返し、
. 見つからなければエラーとします。

image::eval-var.png[align="center"]

以下の実行例では、真の論理値を表す標準変数 `TRUE` と
円周率を表す標準変数 `PI` を評価しています。
また存在しない変数 `foo` では評価が失敗しています。

```
umu:1> TRUE
val it : Bool = TRUE
umu:2> Umu::Math::PI
val it : Float = 3.141592653589793
umu:3> foo

[NameError] Unbound value identifier: 'foo' -- #3 in "<stdin>"
umu:4>
```

==== 宣言と環境


宣言(declaration)は多くの要素から構成される文の一種であり、
変数の名前と式から構成され、
現在の環境(environment)を新しい束縛で拡張します。

```
<宣言(declaration)> ::=
        <val宣言>
      | <fun宣言>
      | <import宣言>
   /* | ,,,, etc */ .

<val宣言(value declaration)> ::= <名前> <式> .
```

宣言は以下のように評価されます。

. 現在の環境の下で再帰的に式を評価し、
. 評価した値を変数に束縛し、
. その束縛で現在の環境を拡張(extend)し、
. 次回の評価では拡張された新しい環境を参照します。

image::eval-decl.png[align="center"]

以下の実行例では、 宣言 `val` を用いて変数 `x`, `y`
そして `z` を宣言しています。

```
umu:1> val x = 3        # 変数 x を宣言
val x : Int = 3
umu:2> val y = 4        # 変数 x を宣言
val y : Int = 4
umu:3> val z = x + y    # 式 x + y を評価し、変数 z を宣言
val z : Int = 7
umu:4>
```


==== 関数と適用式

式 `3 + 4` の中で、記号 `+` は演算子(operator)と呼ばれ、
数値 `3` と `4` は被演算子(operand)と呼ばれます。

image::fun-plus.png[align="center"]

関数型言語では、

* この演算子を一般化して関数(function)、
* 演算子の振る舞いを適用(application)、
* 式 `add 3 4` を適用式(application expression)

と呼びます。適用式は

* ただ１つの演算子式(operator expression)と
* １つかそれ以上の被演算子式(operand expression)の並び

から構成され、演算子式と被演算子式はどちらも式の一種です。

```
<適用式(application language)> ::=
        <演算子式> <被演算子式(1)> { <被演算子式(n)> } .

<演算子式(operator expression)> ::= <式> .

<被演算子式(operand expression)> ::= <式> .
```

ここで、適用式 `add 3 4` を

* 「定数 `3` と `4` を関数 `add` に適用する(apply)」

と表現します。そして適用式は以下のように評価されます。

. 被演算子式(1)から被演算子(n)の各々について
.. 被演算子式を評価し、
.. その結果の値を「実引数」と呼ぶものとし、
. 演算子式を評価し、
.. もし演算子式を評価した値が関数であれば、
*** その関数に「実引数の並び」を適用する。
.. 関数でなければエラーとして扱う。

image::fun-add.png[align="center"]


==== 関数定義と再帰関数

関数を定義(definition)するには、宣言 `fun` を用います。
宣言 `fun` は関数の名前と関数を定義する式から構成されており、
その定義式をラムダ式(lambda expression)と呼びます。

```
<fun 宣言(function declaration)> ::= <名前> <ラムダ式> .
```

以下の実行例では、演算子 `+` を使って関数 `add` を定義し、
それに値 `3` と `4` を適用しています。

```
umu:1> fun add = x y -> x + y
fun add = #<add: { x y -> (+ x y) }>
umu:2> add 3 4
val it : Int = 7
umu:3
```


==== ラムダ式


==== カリー化と部分適用 (empty)



=== オブジェクト指向 (empty)


==== オブジェクトとメッセージ


==== 型とクラス


=== 作用と副作用

文を評価した時、作用(effect)だけでなく別の結果が生じることがあります。
この副次的に発生する結果を副作用(side effect)と呼びます。

image::side-effect.png[align="center"]

副作用は以下の三つに分類されます。

* 乱数発生
* 入出力
* 破壊的代入
** リファレンス
** S-式


== 基本

この章では、関数型言語とオブジェクト指向を
理解するのに必要となる、基本の概念と用語を説明します。
すでに分かっている人であれば、 読み飛ばしてもかまいません。


=== 関数型言語


==== 評価

```
人間：「３と４を足すといくつ？]
計算機：「７です]
```

計算機(computer)は
人間からの質問(question)に対して答え(answer)を返します。

image::compute.png[align="center"]

この処理を関数型言語では評価(evaluation)と呼び、
人間から受ける質問の事を文(statemennt)、
そして人間へ返す答えの事を作用(effect)と呼びます。

image::evaluate.png[align="center"]

ここで、文は式(expression)と宣言(declaration)の二つに分類され、
作用は値(value)と環境(environment)の二つに分類されます。

```
<評価(evaluation)> ::= <文> <作用> .

<文(statement)>    ::= <式> | <宣言> .

<作用(effect)>     ::= <値> | <環境> .
```

以下の実行例であれば、
「式 `3 + 4` を評価した結果は値 `7` である」
と解釈します。 

```
umu:1> 3 + 4
val it : Int = 7
```


==== 式と定数

式(expression)は多くの要素から構成される文の一種であり、
値(value)もまた多くの要素から構成される作用の一種です。

```
<式(expression)> ::=
        <定数>
      | <変数>
      | <適用式>
      | <ラムダ式>
      | <分岐式>
   /* | .... etc */ .

<値(value)> ::=
        <整数>
      | <小数>
      | <文字列>
      | <シンボル>
      | <関数閉包>
   /* | .... etc */ .
```

その中から、最も単純な定数(constant)と演算子(operator)について
評価の方法を以下に示します。

* 定数: [例] `3`
. 定数が表す値を返します。
* 演算子: [例] `+`
. まずその被演算子(operand)を再帰的に評価し、
. その値を元に演算して結果の値を返します。

image::eval-const.png[align="center"]

以下の実行例では、

* 整数を表す定数 `3` 、
* 文字列を表す定数 `"Apple"` そして
* シンボルを表す定数 `@Banana`

を評価しています。

```
umu:1> 3
val it : Int = 3
umu:2> "Apple"
val it : String = "Apple"
umu:3> @Banana
val it : Symbol = @Symbol
umu:4>
```


==== 変数と環境

値には名前を付けることができます。
たとえば円周率を表すのに
毎回 `3.14159265358979` と書くのは
面倒ですからそれを `PI` と命名し、
その名前で円周率の値を表すものと解釈します。
ここで、

* 値に付けられた名前の事を変数(variable)、
* 名前と値との対応関係を束縛(binding)、
* 束縛が記録される辞書の事を環境(environment)

と呼びます。

```
<環境(environment)> ::= { <束縛> } .

<束縛(binding)>     ::= <変数> <値> .

<変数(variable)>    ::= <名前> .
```

また、

* 名前を付ける、すなわち名前と値との対応関係を生む行為を
「(名前に値を)束縛する(bind)」、
* 環境へ新たな束縛を追加する行為を「(環境を)拡張する(extend)」

と表現します。

変数は以下のように評価されます。

* 変数の名前を環境(environment)から探し(lookup)、
. もし見つかれば束縛された値を返し、
. 見つからなければエラーとします。

image::eval-var.png[align="center"]

以下の実行例では、

* 真の論理値を表す標準変数 `TRUE` と
* 円周率を表す標準変数 `PI`
* 足し算関数を表す標準変数 `(+)`

を評価しています。また存在しない変数 `foo` では評価が失敗しています。

```
umu:1> TRUE
val it : Bool = TRUE
umu:2> Umu::Math::PI
val it : Float = 3.141592653589793
umu:3> (+)
fun it = #<+: { x : Number y : Number -> (x).(+ y) }>
umu:4> foo

[NameError] Unbound value identifier: 'foo' -- #4 in "<stdin>"
umu:5>
```

==== 宣言と環境


宣言(declaration)は多くの要素から構成される文の一種であり、
変数と式から構成され、
現在の環境(environment)を新しい束縛で拡張します。

```
<宣言(declaration)> ::=
        <val宣言>
      | <fun宣言>
      | <import宣言>
   /* | .... etc */ .

<val宣言(value declaration)> ::= <変数> <式> .
```

宣言は以下のように評価されます。

. 現在の環境の下で再帰的に式を評価し、
. 評価した値を変数に束縛し、
. その束縛で現在の環境を拡張(extend)し、
. 次回の評価では拡張された新しい環境を参照します。

image::eval-decl.png[align="center"]

以下の実行例では、

. まず変数 `x` と `y` を宣言し、
. その環境の下で式 `x + y` を評価し、
. その評価した値で変数 `z` を宣言しています。

```
umu:1> val x = 3        # 変数 x を宣言
val x : Int = 3
umu:2> val y = 4        # 変数 y を宣言
val y : Int = 4
umu:3> val z = x + y    # 式 x + y を評価し、変数 z を宣言
val z : Int = 7
umu:4>
```

image::ext-env-val.png[align="center"]


==== 関数とカリー化

式 `3 + 4` の中で、記号 `+` は演算子(operator)と呼ばれ、
数値 `3` と `4` は被演算子(operand)と呼ばれます。

image::fun-plus.png[align="center"]

関数型言語では、

* この演算子を一般化して関数(function)、
* 演算子の振る舞いを適用(application)、
* 式 `(+) 3 4` を適用式(application expression)

と呼び、適用式 `(+) 3 4` を

* 「 `3` と `4` を関数 `(+)` に適用する(apply)」

と表現します。

image::fun-add.png[align="center"]

ここで適用式 `(+) 3 4` では、
関数 `(+)` へ２つの引数を渡しているように見えますが、
実際には関数 `(+)` は１入力１出力として定義されており、
以下のように解釈されます。

. 値 `3` を関数 `(+)` へ適用すると、関数 `#<+>` が返る。
. 値 `4` を返ってきた関数 `#<+>` へ適用すると、値 `7` が返る。

image::fun-curry.png[align="center"]

こうした多入力関数を単一入力関数の複合体として定義するスタイルは、
近年のモダンな関数型言語の特徴の一つであり、
単一入力に分解された関数は「カリー化(curryed)された」と呼ばれます。

また、関数が返す値 `#<+>` を関数閉包(function closure)
あるいはクロージャと呼びます。


==== 関数宣言、ラムダ式そして適用式

関数を定義(definition)するには、宣言 `fun` を用います。
宣言 `fun` は関数の名前と関数を定義する式から構成されており、
その定義式をラムダ式(lambda expression)と呼びます。

```
<fun 宣言(function declaration)> ::= <関数名> <ラムダ式> .

<関数名(function name)> ::= <変数> .
```

ラムダ式は

* １つかそれ以上の仮引数(formal parameter, または parameter)の並びと
* 本体式(body expression)

から構成され、それぞれ仮引数は変数、本体式は式の別名です。

```
<ラムダ式(lambda expression)> ::=
        <仮引数(1)> { <仮引数(n)> }  <本体式> .

<仮引数(formal parameter)> ::= <変数> .

<本体式(body expression)> ::= <式> .
```

ラムダ式を評価した結果が関数閉包(function closure)と呼ばれる値であり、

* ラムダ式それ自身と
* ラムダ式を評価した時点の環境

から構成されます。

```
<関数閉包(function closure)> ::= <ラムダ式> <環境> .
```

ラムダ式が評価された時点だと、
その本体式は環境とともに関数閉包の内部に閉じ込められ、
計算を停止しているという状況に注意してください。
この計算の停止は、
(以降で説明する)関数閉包に実引数を適用するまで続きます。

そして、適用式は

* ただ１つの演算子式(operator expression)と
* １つかそれ以上の被演算子式(operand expression)の並び

から構成され、演算子式と被演算子式はどちらも式の別名です。

```
<適用式(application language)> ::=
        <演算子式> <被演算子式(1)> { <被演算子式(n)> } .

<演算子式(operator expression)>  ::= <式> .

<被演算子式(operand expression)> ::= <式> .
```

適用式は以下のように評価されます。

. 被演算子式(1 .. n)の各々について
.. 現在の環境下で被演算子式の並びを評価し、
.. その結果の値を「実引数(actual parameter または argument)の並び」と
呼ぶものとし、
. 現在の環境下で演算子式を評価し、
** もし演算子式を評価した値が関数閉包(クロージャ)であれば、
... 実引数(1 .. n)の各々と関数閉包の仮引数(1 .. n)の各々について
**** 実引数の値を仮引数の変数に束縛し、
... その束縛セットで(閉じ込められていた)関数閉包の環境を拡張し、
... その新しい環境の下で、
(閉じ込められていた)関数閉包の本体式を再帰的に評価する。
** もし関数でなければエラーとして扱う。

以下の実行例では、

. すでに変数 `x`, `y`, `z` が存在する環境下において、
. 関数 `add` を宣言し、
. 数 `30` と `40` を関数 `add` に適用し、
. その結果を元に変数 `z` を宣言しています。

```
umu:4> fun add = x y -> x + y
fun add = #<add: { x y -> (+ x y) }>
umu:5> val z = add 30 40
val z : Int = 70
umu:6>
```

image::ext-env-fun.png[align="center"]


==== 再帰関数と相互再帰



=== オブジェクト指向 (empty)


==== オブジェクトとメッセージ


==== 型とクラス


=== 作用と副作用

文を評価した時、作用(effect)だけでなく別の結果が生じることがあります。
この副次的に発生する結果を副作用(side effect)と呼びます。

image::side-effect.png[align="center"]

副作用は以下の三つに分類されます。

* 乱数発生
* 入出力
* 破壊的代入
** リファレンス
** S-式


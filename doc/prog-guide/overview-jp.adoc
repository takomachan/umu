== 基本

この章では、関数型言語とオブジェクト指向を
理解するのに必要となる、基本の概念と用語を説明します。
すでに分かっている人であれば、 読み飛ばしてもかまいません。


=== 関数型言語


==== 評価

```
人間：「３と４を足すといくつ？]
計算機：「７です]
```

計算機(computer)は
人間からの質問(question)に対して答え(answer)を返します。

image::compute.png[align="center"]

この処理を関数型言語では評価(evaluation)と呼び、
人間から受ける質問の事を文(statemennt)、
そして人間へ返す答えの事を作用(effect)と呼びます。

image::evaluate.png[align="center"]

ここで、文は式(expression)と宣言(declaration)の二つに分類され、
作用は値(value)と環境(environment)の二つに分類されます。

```
<評価(evaluation)> ::= <文> <作用> .

<文(statement)>    ::= <式> | <宣言> .

<作用(effect)>     ::= <値> | <環境> .
```

以下の実行例であれば、
「式 `3 + 4` を評価した結果は値 `7` である」
と解釈します。 

```
umu:1> 3 + 4
val it : Int = 7
```


==== 式と定数

式(expression)は多くの要素から構成される文の一種であり、
値(value)もまた多くの要素から構成される作用の一種です。

```
<式(expression)> ::=
        <定数>
      | <変数>
      | <適用式>
      | <ラムダ式>
      | <分岐式>
   /* | .... etc */ .

<値(value)> ::=
        <整数>
      | <小数>
      | <文字列>
      | <シンボル>
      | <関数閉包>
   /* | .... etc */ .
```

その中から、最も単純な定数(constant)と演算子(operator)について
評価の方法を以下に示します。

* 定数: [例] `3`
. 定数が表す値を返します。
* 演算子: [例] `+`
. まずその被演算子(operand)を再帰的に評価し、
. その値を元に演算して結果の値を返します。

image::eval-const.png[align="center"]

以下の実行例では、

* 整数を表す定数 `3` 、
* 文字列を表す定数 `"Apple"` そして
* シンボルを表す定数 `@Banana`

を評価しています。

```
umu:1> 3
val it : Int = 3
umu:2> "Apple"
val it : String = "Apple"
umu:3> @Banana
val it : Symbol = @Symbol
umu:4>
```


==== 変数と環境

値には名前を付けることができます。
たとえば円周率を表すのに
毎回 `3.14159265358979` と書くのは
面倒ですからそれを `PI` と命名し、
その名前で円周率の値を表すものと解釈します。
ここで、

* 値に付けられた名前の事を変数(variable)、
* 名前と値との対応関係を束縛(binding)、
* 束縛が記録される辞書の事を環境(environment)

と呼びます。

```
<環境(environment)> ::= { <束縛> } .

<束縛(binding)>     ::= <変数> <値> .

<変数(variable)>    ::= <名前> .
```

また、

* 名前を付ける、すなわち名前と値との対応関係を生む行為を
「(名前に値を)束縛する(bind)」、
* 環境へ新たな束縛を追加する行為を「(環境を)拡張する(extend)」

と表現します。

変数は以下のように評価されます。

* 変数の名前を環境(environment)から探し(lookup)、
. もし見つかれば束縛された値を返し、
. 見つからなければエラーとします。

image::eval-var.png[align="center"]

以下の実行例では、

* 真の論理値を表す標準変数 `TRUE` と
* 円周率を表す標準変数 `PI`
* 足し算関数を表す標準変数 `(+)`

を評価しています。また存在しない変数 `foo` では評価が失敗しています。

```
umu:1> TRUE
val it : Bool = TRUE
umu:2> Umu::Math::PI
val it : Float = 3.141592653589793
umu:3> (+)
fun it = #<+: { x : Number y : Number -> (x).(+ y) }>
umu:4> foo

[NameError] Unbound value identifier: 'foo' -- #4 in "<stdin>"
umu:5>
```

==== 宣言と環境


宣言(declaration)は多くの要素から構成される文の一種であり、
変数と式から構成され、
現在の環境(environment)を新しい束縛で拡張します。

```
<宣言(declaration)> ::=
        <val宣言>
      | <fun宣言>
      | <import宣言>
   /* | .... etc */ .

<val宣言(value declaration)> ::= <変数> <式> .
```

宣言は以下のように評価されます。

. 現在の環境の下で再帰的に式を評価し、
. 評価した値を変数に束縛し、
. その束縛で現在の環境を拡張(extend)し、
. 次回の評価では拡張された新しい環境を参照します。

image::eval-decl.png[align="center"]

以下の実行例では、

. まず変数 `x` と `y` を宣言し、
. その環境の下で式 `x + y` を評価し、
. その評価した値で変数 `z` を宣言しています。

```
umu:1> val x = 3        # 変数 x を宣言
val x : Int = 3
umu:2> val y = 4        # 変数 y を宣言
val y : Int = 4
umu:3> val z = x + y    # 式 x + y を評価し、変数 z を宣言
val z : Int = 7
umu:4>
```

image::ext-env-val.png[align="center"]


==== 関数とカリー化

式 `3 + 4` の中で、記号 `+` は演算子(operator)と呼ばれ、
数値 `3` と `4` は被演算子(operand)と呼ばれます。

image::fun-plus.png[align="center"]

関数型言語では、

* この演算子を一般化して関数(function)、
* 演算子の振る舞いを適用(application)、
* 式 `(+) 3 4` を適用式(application expression)

と呼び、適用式 `(+) 3 4` を

* 「 `3` と `4` を関数 `(+)` に適用する(apply)」

と表現します。

image::fun-add.png[align="center"]

ここで適用式 `(+) 3 4` では、
関数 `(+)` へ２つの引数を渡しているように見えますが、
実際には関数 `(+)` は１引数として定義されており、
以下のように解釈されます。

. 値 `3` を関数 `(+)` へ適用すると、関数 `#<+>` が返る。
. 値 `4` を返ってきた関数 `#<+>` へ適用すると、値 `7` が返る。

image::fun-curry.png[align="center"]

こうした多引数関数を単一引数関数の複合体として定義するスタイルは、
近年のモダンな関数型言語の特徴の一つであり、
単一引数に分解された関数は「カリー化(curryed)された」と呼ばれます。

また、関数が返す値 `#<+>` を関数閉包(function closure)
あるいはクロージャと呼びます。

以下の実行例では、

. まず単純に式 `3 + 4` を評価して結果が値 `7` である事を確認し、
. 続いて足し算関数を表す変数 `(+)` を評価し、
. その評価した値である関数閉包 `#<+>` に値 `3` を適用し、
. その適用の結果である関数閉包 `#<+>` に値 `4` を適用して
. 結果が値 `7` であることを確認しています。

```
umu:1> 3 + 4
val it : Int = 7
umu:2> (+)
fun it = #<+: { x : Number y : Number -> (x).(+ y) }>
umu:3> it 3
fun it = #<+: { y : Number -> (x).(+ y) }>
umu:4> it 4
val it : Int = 7
umu:5>
```


==== 関数宣言、ラムダ式そして適用式

関数を定義(definition)するには、宣言 `fun` を用います。
宣言 `fun` は関数の名前と関数を定義する式から構成されており、
その定義式をラムダ式(lambda expression)と呼びます。

```
<fun 宣言(function declaration)> ::= <関数名> <ラムダ式> .

<関数名(function name)> ::= <変数> .
```

ラムダ式は

* １つかそれ以上の仮引数(formal parameter, または parameter)の並びと
* 本体式(body expression)

から構成され、それぞれ仮引数は変数、本体式は式の別名です。

```
<ラムダ式(lambda expression)> ::=
        <仮引数(1)> { <仮引数(n)> }  <本体式> .

<仮引数(formal parameter)> ::= <変数> .

<本体式(body expression)> ::= <式> .
```

ラムダ式を評価した結果が関数閉包(function closure)と呼ばれる値であり、

* ラムダ式それ自身と
* ラムダ式を評価した時点の環境

から構成されます。

```
<関数閉包(function closure)> ::= <ラムダ式> <環境> .
```

ラムダ式が評価された時点だと、
その本体式は環境とともに関数閉包の内部に閉じ込められ、
計算を停止しているという状況に注意してください。
この計算の停止は、
(以降で説明する)関数閉包に実引数を適用するまで続きます。

そして、適用式は

* ただ１つの演算子式(operator expression)と
* １つかそれ以上の被演算子式(operand expression)の並び

から構成され、演算子式と被演算子式はどちらも式の別名です。

```
<適用式(application language)> ::=
        <演算子式> <被演算子式(1)> { <被演算子式(n)> } .

<演算子式(operator expression)>  ::= <式> .

<被演算子式(operand expression)> ::= <式> .
```

適用式は以下のように評価されます。

. 被演算子式(1 .. n)の各々について
.. 現在の環境下で被演算子式の並びを評価し、
.. その結果の値を「実引数(actual parameter または argument)の並び」と
呼ぶものとし、
. 現在の環境下で演算子式を評価し、
** もし演算子式を評価した値が関数閉包(クロージャ)であれば、
... 実引数(1 .. n)の各々と関数閉包の仮引数(1 .. n)の各々について
**** 実引数の値を仮引数の変数に束縛し、
... その束縛セットで(閉じ込められていた)関数閉包の環境を拡張し、
... その新しい環境の下で、
(閉じ込められていた)関数閉包の本体式を再帰的に評価する。
** もし関数でなければエラーとして扱う。

以下の実行例では、

. すでに変数 `x`, `y`, `z` が存在する環境下において、
. 関数 `add` を宣言し、
. 数 `30` と `40` を関数 `add` に適用し、
. その結果を元に変数 `z` を宣言しています。

```
umu:4> fun add = x y -> x + y
fun add = #<add: { x y -> (+ x y) }>
umu:5> val z = add 30 40
val z : Int = 70
umu:6>
```

image::ext-env-fun.png[align="center"]

前提とする環境に応じて変数の値は変わります。たとえば

* 変数 `x` は `3` あるいは `30`
* 変数 `z` は `7` あるいは `70` です。

自然語で周囲の状況(あるいは空気)に応じて言葉の意味が変わるのと似ています。
この性質から、環境の事を文脈(context)と呼ぶことがあります。

また環境が枝分かれした先で起こる変化は、枝の元に影響を及ぼしません。
たとえば枝の先で変数 `x` は値 `30` に変化しますが、
枝分かれの元では `3` のままです。

そして環境の枝分かれは適用式を評価するたびに発生し、環境をノードとする
階層的なツリーが作られることになります。

image::ext-env-tree.png[align="center"]


==== 再帰関数と相互再帰 (empty)


==== データ型と値 (empty)



=== オブジェクト指向


==== オブジェクト指向パラダイム

```
人間：「３と４を足すといくつ？]
計算機：「７です]
```

この計算機との対話を関数型言語では、

* 値 `3` と `4` を関数 `(+)` に適用(apply)すると値 `7` が返る

と解釈すると説明してきました。

image::fun-add.png[align="center"]

関数型パラダイムにおいて計算の主役は関数(function)であり、
３や４といった値(value)は脇役です。

これに対してオブジェクト指向パラダイムでは、

* 関数
* ３や４といった値、

これらすべてを平等に計算の主役であると考えてオブジェクト(object)と呼び、

* オブジェクト `3` にメッセージ `.+ 4` を送信(send)すると
    オブジェクト `7` が返る、

あるいはメッセージを受信するオブジェクトの視点で、

* オブジェクト `3` はメッセージ `.+ 4` を受信(receive)すると
    オブジェクト `7` を返す

と解釈し、送信式 `3.+ 4` で表現します。

image::send-add.png[align="center"]

オブジェクトはメッセージの種類に応じて適切に振る舞うことができます。
たとえば整数オブジェクト `3` は、

* メッセージ `.* 4`  に対して整数オブジェクト  `12`    を返し、
* メッセージ `.odd?` に対して論理値オブジェクト `TRUE` を返し、
* メッセージ `.show` に対して文字列オブジェクト `"3"`  を返します。

また関数もまたオブジェクトですから、関数オブジェクト `(+)` は
適用メッセージ `.apply-binary 3 4` に対して整数オブジェクト `7` を返します。
これは、関数への適用をメッセージの送信で模倣していると見なすことができます。

```
umu:1> 3 + 4
val it : Int = 7
umu:2> 3 * 4
val it : Int = 12
umu:3> 3.odd?
val it : Bool = TRUE
umu:4> 3.show
val it : String = "3"
umu:5> (+).apply-binary 3 4
val it : Int = 7
umu:6
```

image::send-mul.png[align="center"]

他にも式(expression)や宣言(declaration)をオブジェクトであると見なせば、

* 式オブジェクト `3 + 4` は評価メッセージ `.evaluate env` に対して
    値オブジェクト `7` を返し、
* 宣言オブジェクト `val x = 3` は評価メッセージ `.evaluate env` に対して、
    現在の環境 `env` を束縛 `x => 3` で拡張した
    新しい環境オブジェクト `env'` を返します。

image::send-to-expr.png[align="center"]

更に環境(environment)もオブジェクトであると見なせば、環境オブジェクトは

* 拡張メッセージ `.extend @x 3` に対して
    束縛 `x => 3` で拡張された新しい環境オブジェクト `env'` を返し、
* 検索メッセージ `.lookup @x` に対して
** 見つかれば整数オブジェクト `3` を返し、
** 見つからなければ例外 `NameError` を起動します。

image::send-to-env.png[align="center"]

以下の実行例では、

. インタプリタを起動した直後の環境下で変数 `x` を評価すると、
例外 `NameError` が発生することを確認した後、
. 変数 `x` を宣言し、
. この環境下で再び変数 `x` を評価すると、
今度は値 `3` が返ることを確認しています。

```
umu:1> x

[NameError] Unbound value identifier: 'x' -- #1 in "<stdin>"
umu:2> val x = 3
val x : Int = 3
umu:3> x
val it : Int = 3
umu:4>
```


==== メッセージとカリー化

オブジェクトへ送信するメッセージについて与える引数の個数に着目すると、

* 単項メッセージ(unary message): 引数は無し(メッセージセレクタのみ)
** [例] Int#odd? : Bool
** [例] Int#show : String
* 二項メッセージ(binary message): 引数は１個のみ
** [例] Int#+ : Int -> Int
** [例] Int#* : Int -> Int
** [例] Expression#evaluate : Environment -> Value
** [例] Declaration#evaluate : Environment -> Environment
** [例] Environment#lookup : Symbol -> Value
* 多項メッセージ(n-ary message): 引数は２個かそれ以上
** [例] Fun#apply-binary : Top -> Top -> Top
** [例] Environment#extend : Symbol -> Value -> Environment
** [例] Environment#apply-binary : Top -> Top -> Top

にの三つに分類されます。

ここで、すべての関数が単一引数関数の複合体として定義され、
そうしたスタイルがカリー化と呼ばれていたことを思い出してください。
メッセージも同じく、

* すべてのメッセージは単項メッセージとその複合体によって定義され、

二項メッセージを使う送信式 `3.+ 4` は、以下のように解釈されます。

. 整数オブジェクト `3` へメッセージ `.+` を送信(send)すると、
関数オブジェクト(= 関数閉包 or クロージャ) `#<+: ..>` が返る。
. 返ってきた 関数オブジェクトに整数オブジェクト `4` を適用(apply)すると、
整数オブジェクト `7` が返る。

```
umu:1> 3.+ 4
val it : Int = 7
umu:2> 3.+
fun it = #<{ %x_1 -> (%r).(+ %x_1) }>
umu:3> it 4
val it : Int = 7
umu:4>
```

image::send-curry-binary.png[align="center"]

多項メッセージも同じように解釈します。

```
umu:1> (+).apply-binary 3 4
val it : Int = 7
umu:2> (+).apply-binary
fun it = #<{ %x_1 %x_2 -> (%r).(apply-binary %x_1 %x_2) }>
umu:3> it 3
fun it = #<{ %x_2 -> (%r).(apply-binary %x_1 %x_2) }>
umu:4> it 4
val it : Int = 7
umu:5>
```

image::send-curry-nary.png[align="center"]


==== 送信式とメッセージ

オブジェクトにメッセージを送信する送信式(send expression)は式の一種であり、
レシーバ式と１つかそれ以上のメッセージの並びから構成され、
レシーバ式は式の別名です。

```
<送信式(send expression)> ::=
        <レシーバ式>
        <メッセージ(1)> { <メッセージ(n)> } .

<レシーバ式(receiver expression)> ::= <式> .
```

またメッセージはメッセージセレクタとメッセージ引数の並びから構成され、
メッセージセレクタは文字 `'.'` で始まるトークンであり、
メッセージ引数は式の別名です。

```
<メッセージ(message)> ::=
        <メッセージセレクタ>
        <メッセージ引数(1)> { <メッセージ引数(n)> } .

<メッセージ引数(message parameter)> ::= <式> .
```

ここで、オブジェクトは内部に

* 受信したメッセージに応じた適切な振る舞いの定義、および
* メッセージセレクタとキーとして振る舞い定義への対応が記録された辞書

を持ち、

* メッセージに応じた振る舞いの定義をメソッド(method)、
* メッセージセレクタとメソッドの対応が記録された辞書を
        メソッドテーブル(method table)

と呼びます。

送信式は以下のように評価されます。

. レシーバ式を評価しレジーバオブジェクトを得て、
. メッセージ(1..n)の各々について
.. 当該メッセージ引数の並びを評価し、
.. レシーバオブジェクトのメソッドテーブルから
        当該メッセージセレクタを検索し、
*** もし見つかれば
.... メッセージセレクタに対応するメソッドを取得し、
.... 取得したメソッドに評価したメッセージ引数の並びを与えて
        呼び出し(invoke)、
.... メソッドが返したオブジェクトを次回のレシーバとする。
*** もし見つからなければ
.... 未知のメッセージには応答できない旨のエラーとして扱う。


==== クラスとインスタンス

オブジェクト `3` はメッセージ `.+ 4` に対して `7` を返し、
同様にオブジェクト `4` はメッセージ `.+ 4` に対して `8` を返します。
こうした振る舞いの類似したオブジェクトの集まりをクラス(class)と呼び、
`3` や `4` などのオブジェクトをインスタンス(instance)と呼びます。

素朴な集合論であれば、

* インスタンス `3` や `4` は要素(element)、そして
* 整数クラス `Int` は部分集合(subset)であり、

その全体集合をクラス `Top` と呼びます。
以下に、この集合の構造をベン図で示します。

image::object-as-set.png[align="center"]


==== 抽象クラスと具象クラス

オブジェクトには整数 `3` や `4` だけでなく、
`3.14` や `2.17` といった小数も存在し、小数クラス `Float` に所属します。
小数クラスのオブジェクトは整数クラスのオブジェクトと同様、
メッセージ `.+` や `.*` などに対して適切に振る舞うことが可能です。
この振る舞いの類似したクラスの集まりをスーパークラス(superclass)と呼び、
下位のクラスをサブクラス(subclass)と呼びます。
また一般的に、こうした下位の概念から上位の概念を導く事は
抽象化(abstraction)と呼ばれています。

集合論であれば、たとえば

* 整数クラス `Int` や小数クラス `Float` はサブクラス、
    すなわち部分集合(subset)であり、そして
* 数クラス `Number` はスーパークラス、
    すなわち親集合(superset)であり、
* これらのクラスは入れ子集合(nested set)を形成します。

以下に入れ子集合の一例について、その構造をベン図で示します。

image::superset-subset.png[align="center"]

またサブクラスの集まりからスーパークラスを導くボトムアップな視点とは逆に、
あるクラスに着目し更に分類を細分化していくつかのサブクラスを導くという
トップダウンな視点もあります。このケースを継承(inheritance)と呼びます。

ここで責務に着目すると、クラスは以下の二つに分類されます。

* 抽象クラス(abstract class)
** [責務] クラス継承により生ずる抽象化
** [特徴]
*** サブクラスを持つ、すなわち部分集合(subset)を持つ
*** 直下にインスタンス、すなわち要素(element)は持たない
** [例] Top, Atom, Number
* 具象クラス(concrete class)
** [責務] クラスの具体化、いわゆるインスタンスの生成
** [特徴]
*** インスタンスを持つ、すなわち要素(element)を持つ
*** サブクラス、すなわち部分集合(subset)は持たない
** [例] Int, Float, Bool, Fun

入れ子集合を樹(ツリー)に見立てれば、

* 幹や枝が抽象クラス
* 末端の葉っぱが具象クラス

になります。

image::nestedset-as-tree.png[align="center"]

実際のクラス階層を以下に示します。
クラス名の末尾が文字 `/` であれば抽象クラス、さもなければ具象クラスです。

```
umu:1> :class
Top/
    Class
    Device
    Object/
        Atom/
            Bool
            Number/
                Float
                Int
            String
            Symbol
        Dir
        Fun
        IO/
            Input
            Output
        Morph/
            Enum
            Interval
            List/
                Cons
                Nil
        Product/
            Named
            Tuple
        Ref
        SExpr/
            SExprCons
            SExprNil
            SExprValue
        Stream/
            CellStream
            ExprStream
            MemoStream
            SuspStream
        Susp
        Union/
            Datum
            Option/
                None
                Some
            Result/
                Err
                Ok
        Unit
    Opaque
    StreamCell/
        StreamCons
        StreamNil
    Struct
umu:2>
```


=== 作用と副作用

文を評価した時、作用(effect)だけでなく別の結果が生じることがあります。
この副次的に発生する結果を副作用(side effect)と呼びます。

image::side-effect.png[align="center"]

副作用は以下の三つに分類されます。

* 乱数発生
* 入出力
* 破壊的代入
** リファレンス
** S-式


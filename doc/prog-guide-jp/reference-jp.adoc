## リファレンス

リファレンス(reference, 参照)は可変(mutable)なメモリ領域を表現するオブジェクトです。
ここまで、ある変数に値を割り当てる操作を束縛(binding)と呼んできました。
これは関数型言語では一般的ですが、手続き型言語では以下に示す別の視点で変数に値を割り当てます。

- 「変数」とは、メモリ領域へ紐付けた名札(label, ラベル)である
- 「変数の値」とは、変数で指定されるメモリ領域から保存されている値を読み出す操作である
- 「変数に値を割り当てる」とは、値を変数で指定されるメモリ領域へ書き込む操作である

この仕組みは破壊的代入(destructive assignment)と呼ばれています。

この破壊的代入をオブジェクト指向で実装したものがリファンスオブジェクトであり、
以下のメッセージに対して応答します。

- &Ref.make : Top -> Ref
+
引数を初期値とするメモリ領域を１つ確保し、それをリファレンスで返す
- Ref#peek! : Top
+
リファレンスが持つメモリ領域に保存されている値を読み出し、それを返す
- Ref#poke! : Top -> Unit
+
引数の値をリファレンスが持つメモリ領域へ書き込む

```
umu:1> val rx = &Ref.make 3        # 3 を初期値とするリファレンスを定義
val rx : Ref = #Ref<3>
umu:2> rx.peek!                    # リファレンスから現在の値を読み出す ==> 3
val it : Int = 3
umu:3> rx.peek!.+ 4 |> rx.poke!    # 現在の値に 4 を足し、その結果をリファレンスへ書き込む
val it : Unit = ()
umu:4> rx.peek!                    # リファレンスから現在の値を読み出す ==> 7
val it : Int = 7
umu:5>
```

単純な機能(service)ですが、冗長です。
そこで、これらのメッセージを抽象化した標準関数 `ref` および標準演算子 `!!` と `:=` を提供します。

```
umu:1> val rx = ref 3                # 3 を初期値とするリファレンスを定義
val rx : Ref = #Ref<3>
umu:2> !!rx                          # リファレンスから現在の値を読み出す ==> 3
val it : Int = 3
umu:3> rx := !!rx + 4                # 現在の値に 4 を足し、その結果をリファレンスへ書き込む
val it : Unit = ()
umu:4> !!rx                          # リファレンスから現在の値を読み出す ==> 7
val it : Int = 7
umu:5>
```

```
umu:1> val rx = ref 3                # 3 を初期値とするリファレンス rx を定義
val rx : Ref = #Ref<3>
umu:2> val ry = ref 4                # 4 を初期値とするリファレンス ry を定義
val ry : Ref = #Ref<4>
umu:3> !!rx + !!ry                   # リファレンス rx から読み出した値と同 ry から読み出した値を足す
val it : Int = 7
umu:4>
```

破壊的代入に興味を持たれたなら、`Lisp` を使ったコンピュータサイエンスの教科書である
link:https://sicp.iijlab.net/[SICP]の
link:https://sicp.iijlab.net/fulltext/x310.html[節 3.1 代入と局所状態]
を参照してください。
またリファレンスを使うよう書き改めたコードが
link:example/sicp//sicp-ch3.umu[SICPの例]
にあります。


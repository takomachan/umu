import Umu { structure SE = SExpr }


#### 3 Modularity, Objects, and State
#### 3 標準部品化力、オブジェクトおよび状態 -- p127

;; print "\n\nCHAPTER 3"
;;



#### 3.1 Assignment and Local State
#### 3.1 代入と局所状態 -- p127

;; print "\n\nSECTION 3.1"
;;



#### 3.1.1 Local State Variables
#### 3.1.1 局所状態変数 -- p128

;; print "\n\nSECTION 3.1.1"
;;

val ref-balance = ref 100

fun withdraw = amount -> (
    if !!ref-balance >= amount then do (
        ! ref-balance := !!ref-balance - amount
        ! Ok <| !!ref-balance
    ) else
        Err <| "Insufficient funds"
)

;; !!ref-balance
# -> 100
;; withdraw 25
# -> &Ok 75
;; withdraw 25
# -> &Ok 50
;; withdraw 60
# -> &Err "Insufficient funds"
;; withdraw 15
# -> &Ok 35
;;


val new-withdraw = let {
    val ref-balance = ref 100
in
    {
        amount
    ->
        if !!ref-balance >= amount then do (
            ! ref-balance := !!ref-balance - amount
            ! Ok <| !!ref-balance
        ) else
            Err <| "Insufficient funds"
    }
}


fun make-withdraw = balance -> let {
    val ref-balance = ref balance
in {
        amount
    ->
        if !!ref-balance >= amount then do (
            ! ref-balance := !!ref-balance - amount
            ! Ok <| !!ref-balance
        ) else
            Err <| "Insufficient funds"
    }
}

val W1 = make-withdraw 100
val W2 = make-withdraw 100
 
;; W1 50
# -> &Ok 50
;; W2 70
# -> &Ok 30
;; W2 40
# -> &Err "Insufficient funds"
;; W1 40
# -> &Ok 10
;;


fun make-account = balance -> let {
    val ref-balance = ref balance

    fun withdraw = amount ->
        if !!ref-balance >= amount then do (
            ! ref-balance := !!ref-balance - amount
            ! Ok <| !!ref-balance
        ) else
            Err <| "Insufficient funds"

    fun deposit = amount -> do (
        ! ref-balance := !!ref-balance + amount
        ! !!ref-balance
    )

    fun dispatch = m -> case m of {
      | @withdraw -> withdraw
      | @deposit  -> deposit
      else        -> panic! ("Unknown request -- MAKE-ACCOUNT: " ^ show m)
    }
in
    dispatch
}


val acc = make-account 100

;; acc @withdraw <| 50
# -> &Ok 50
;; acc @withdraw <| 60
# -> &Err "Insufficient funds"
;; acc @deposit <| 40
# -> 90
;; acc @withdraw <| 60
# -> 30



#### 3.1.2 The Benefits of Introducing Assignment
#### 3.1.2 代入を取り入れた利点 -- p131

;; print "\n\nSECTION 3.1.2"
;;



#### 3.1.3 The Costs of Introducing Assignment
#### 3.1.3 代入を取り入れた代価 -- p134

;; print "\n\nSECTION 3.1.3"
;;

fun make-simplified-withdraw = balance -> let {
    val ref-balance = ref balance
in  {
        amount
    -> do (
            ! ref-balance := !!ref-balance - amount
            ! !!ref-balance
        )
    }
}

val W = make-simplified-withdraw 25

;; W 20
# -> 5
;; W 10
# -> -5
;;


fun make-decrementer = balance -> {
    amount
->
    balance - amount
}

val D = make-decrementer 25

;; D 20
# -> 5
;; D 10
# -> 15
;;



#### 3.2 The Environment Model of Evaluation
#### 3.2 評価の環境モデル -- p138

;; print "\n\nSECTION 3.2"
;;



#### 3.2.1 The Rules for Evaluation
#### 3.2.1 評価の規則 -- p138

;; print "\n\nSECTION 3.2.1"
;;



#### 3.2.2 Applying Simple Procedures
#### 3.2.2 単純な手続きの作用 -- p140

;; print "\n\nSECTION 3.2.2"
;;



#### 3.2.3 Frames as the Repository of Local State
#### 3.2.3 局所状態の入れ物としてのフレーム -- p142

;; print "\n\nSECTION 3.2.3"
;;



#### 3.2.4 Internal Definitions
#### 3.2.4 内部定義 -- p145

;; print "\n\nSECTION 3.2.4"
;;



#### 3.3 Modeling with Mutable Data
#### 3.3 可変データでのモデル化 -- p147

;; print "\n\nSECTION 3.3"
;;



#### 3.3.1 Mutable List Structure
#### 3.3.1 可変リスト構造 -- p147

;; print "\n\nSECTION 3.3.1"
;;



#### 3.3.2 Representing Queues
#### 3.3.2 キューの表現 -- p153

;; print "\n\nSECTION 3.3.2"
;;



#### 3.3.3 Representing Tables
#### 3.3.3 表の表現 -- p156

;; print "\n\nSECTION 3.3.3"
;;

###     assoc : Symbol -> SExpr -> Option SExpr
fun rec assoc = (key : Symbol) (records : SExpr) -> cond records of {
| SE::Nil?  -> NONE
| SE::Atom? -> panic! <| "Unexpected atom: " ^ records.show
| SE::Cons? -> let {
        val (car: cdr:) = val-of records
    in
        if SE::Cons? car && key == (val-of <| SE::car car)
            then Some car
            else assoc key cdr
    }
}


### lookup1 = Symbol -> SExpr -> Option SExpr
fun lookup1 = (key : Symbol) (table : SExpr) -> let {
    val opt-record = assoc key <| SE::cdr table
in
    case opt-record of {
    | &Some cons -> Some <| SE::cdr cons
    | &None      -> NONE
    }
}


fun insert1! = (key : Symbol) (value : SExpr) (table : SExpr) -> let {
    val opt-record = assoc key <| SE::cdr table
in
    case opt-record of {
    | &Some record -> SE::set-cdr! record value 
    | &None        -> SE::set-cdr! table (
                          SE::Cons
                              (SE::Cons (SE::Atom key) value)
                              (SE::cdr table)
                      )
    }
}


fun make-table = records : List -> (SE::Cons
    (SE::Cons
        (SE::Atom @"*table*")
        SE::NIL
    )

    (records |> foldr SE::NIL { (k : Symbol, v : SExpr) (se : SExpr) ->
            SE::Cons
                (SE::Cons (SE::Atom k) v)
                se
        }
    )
)



;; val t1 = make-table [
    (@a, (SE::Atom 1)),
    (@b, (SE::Atom 2)),
    (@c, (SE::Atom 3))
]
(#
    a:  1
    b:  2
    c:  3
#)

;; t1
# -> ((@*table*) (@a . 1) (@b . 2) (@c . 3))
;; lookup1 @b t1
# -> &Some 2
;; lookup1 @d t1
# -> &None ()
;; insert1! @d (SE::Atom 4) t1
# -> ()
;; t1
# -> ((@*table*) (@d . 4) (@a . 1) (@b . 2) (@c . 3))
;; insert1! @b (SE::Atom 20) t1
# -> ()
;; t1
# -> ((@*table*) (@d . 4) (@a . 1) (@b . 20) (@c . 3))
;;



#### two-dimensional ####

(### lookup2 = Symbol ->
                Symbol ->
                <TABLE> [(Symbol, [(Symbol, 'a)])] ->
                Option 'a
###)
fun lookup2 = (key-1 : Symbol) (key-2 : Symbol) (table : SExpr) -> let {
    val opt-subtable = assoc key-1 <| SE::cdr table
in
    case opt-subtable of {
    | &Some subtable -> let {
            val opt-record = assoc key-2 <| SE::cdr subtable
        in
            case opt-record of {
            | &Some record -> Some <| SE::cdr record
            | &None        -> NONE
            }
        }
    | &None -> NONE
    }
}


fun insert2! = (key-1 : Symbol) (key-2 : Symbol)
               (value : SExpr) (table : SExpr) -> let {
    val opt-subtable = assoc key-1 <| SE::cdr table
in
    case opt-subtable of {
    | &Some subtable -> let {
            val opt-record = assoc key-2 <| SE::cdr subtable
        in
            case opt-record of {
            | &Some record -> SE::set-cdr! record value
            | &None        -> SE::set-cdr! subtable (
                                  SE::Cons
                                      (SE::Cons (SE::Atom key-2) value)
                                      (SE::cdr subtable)
                              )
            }
        }
    | &None -> SE::set-cdr! table (
                   SE::Cons
                       (SE::make [
                               key-1,
                               (SE::Cons (SE::Atom key-2) value)
                           ]
                       )
                       (SE::cdr table)
               )
    }
}


;; val t2 = make-table [
                (@math,
                    (SE::make [
                            (SE::Cons (SE::Atom @"+") (SE::Atom 43)),
                            (SE::Cons (SE::Atom @"-") (SE::Atom 45)),
                            (SE::Cons (SE::Atom @"*") (SE::Atom 42))
                        ]
                    )
                ),

                (@letters,
                    (SE::make [
                            (SE::Cons (SE::Atom @a) (SE::Atom 97)),
                            (SE::Cons (SE::Atom @b) (SE::Atom 98))
                        ]
                    )
                )
            ]
(#
    math:
        +: 43
        -: 45
        *: 42
    letters:
        a: 97
        b: 98
#)

;; t2
# -> (
#    (@*table*)
#    (@math (@+ . 43) (@- . 45) (@* . 42))
#    (@letters (@a . 97) (@b . 98))
# )
;; lookup2 @math @"-" t2
# -> &Some 45
;; lookup2 @letters @a t2
# -> &Some 97
;; lookup2 @nath @"-" t2
# -> &None ()
;; lookup2 @math @"/" t2
# -> &None ()
;; insert2! @math @"/" (SE::Atom 40) t2
# -> ()
;; t2
# -> (
#     (@*table*)
#     (@math (@/ . 40) (@+ . 43) (@- . 45) (@* . 42))
#     (@letters (@a . 97) (@b . 98))
# )
;; insert2! @math @"-" (SE::Atom 999) t2
# -> ()
;; t2
# -> (
#     (@*table*)
#     (@math (@/ . 40) (@+ . 43) (@- . 999) (@* . 42))
#     (@letters (@a . 97) (@b . 98))
# )
;; insert2! @letters @"c" (SE::Atom 99) t2
# -> ()
;; t2
# -> (
#     (@*table*)
#     (@math (@/ . 40) (@+ . 43) (@- . 999) (@* . 42))
#     (@letters (@c . 99) (@a . 97) (@b . 98))
# )
;; insert2! @letters @"a" (SE::Atom 10000) t2
# -> ()
;; t2
# -> (
#     (@*table*)
#     (@math (@/ . 40) (@+ . 43) (@- . 999) (@* . 42))
#     (@letters (@c . 99) (@a . 10000) (@b . 98))
# )
;;


#### local tables ####

fun make-table' = records -> let {
    val local-table = make-table records

    fun lookup = key1 key2 -> let {
        val opt-subtable = assoc key1 (SE::cdr local-table)
    in
        if Some? opt-subtable then let {
            val opt-record = assoc key2 (SE::cdr (val-of opt-subtable))
        in
            if Some? opt-record then Some (SE::cdr (val-of opt-record))
                                else NONE
        } else NONE
    }

    fun dispatch = m -> case m of {
    | @lookup-proc -> lookup
    else           -> panic! <| "Unknown operation -- TABLE: " ^ show m
    }
in
    dispatch
}

val operation-table = make-table' [
                    (@math,
                        (SE::make [
                                (SE::Cons (SE::Atom @"+") (SE::Atom 43)),
                                (SE::Cons (SE::Atom @"-") (SE::Atom 45)),
                                (SE::Cons (SE::Atom @"*") (SE::Atom 42))
                            ]
                        )
                    ),

                    (@letters,
                        (SE::make [
                                (SE::Cons (SE::Atom @a) (SE::Atom 97)),
                                (SE::Cons (SE::Atom @b) (SE::Atom 98))
                            ]
                        )
                    )
                ]

val get = operation-table @lookup-proc


;; operation-table
# -> #<dispatch: ....>

;; get
# -> #<lookup: ....>

;; get @math @"-"
# -> &Some 45

;; get @letters @a
# -> &Some 97

;; get @nath @"-"
# -> &None ()

;; get @math @"/"
# -> &None ()
;;

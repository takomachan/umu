structure SE = Umu::SExpr


#### 3 Modularity, Objects, and State
#### 3 標準部品化力、オブジェクトおよび状態 -- p127

;; print "\n\nCHAPTER 3"
;;



#### 3.1 Assignment and Local State
#### 3.1 代入と局所状態 -- p127

;; print "\n\nSECTION 3.1"
;;



#### 3.1.1 Local State Variables
#### 3.1.1 局所状態変数 -- p128

;; print "\n\nSECTION 3.1.1"
;;

val ref-balance = ref 100

fun withdraw = amount -> (
    if !!ref-balance >= amount then do (
        ! ref-balance := !!ref-balance - amount
        ! Ok <| !!ref-balance
    ) else
        Err <| "Insufficient funds"
)

;; !!ref-balance
# -> 100
;; withdraw 25
# -> &Ok 75
;; withdraw 25
# -> &Ok 50
;; withdraw 60
# -> &Err "Insufficient funds"
;; withdraw 15
# -> &Ok 35
;;


val new-withdraw = let {
    val ref-balance = ref 100
in
    {
        amount
    ->
        if !!ref-balance >= amount then do (
            ! ref-balance := !!ref-balance - amount
            ! Ok <| !!ref-balance
        ) else
            Err <| "Insufficient funds"
    }
}


fun make-withdraw = balance -> let {
    val ref-balance = ref balance
in {
        amount
    ->
        if !!ref-balance >= amount then do (
            ! ref-balance := !!ref-balance - amount
            ! Ok <| !!ref-balance
        ) else
            Err <| "Insufficient funds"
    }
}

val W1 = make-withdraw 100
val W2 = make-withdraw 100
 
;; W1 50
# -> &Ok 50
;; W2 70
# -> &Ok 30
;; W2 40
# -> &Err "Insufficient funds"
;; W1 40
# -> &Ok 10
;;


fun make-account = balance -> let {
    val ref-balance = ref balance

    fun withdraw = amount ->
        if !!ref-balance >= amount then do (
            ! ref-balance := !!ref-balance - amount
            ! Ok <| !!ref-balance
        ) else
            Err <| "Insufficient funds"

    fun deposit = amount -> do (
        ! ref-balance := !!ref-balance + amount
        ! !!ref-balance
    )

    fun dispatch = m -> case m of {
      | @withdraw -> withdraw
      | @deposit  -> deposit
      else        -> panic! ("Unknown request -- MAKE-ACCOUNT: " ^ show m)
    }
in
    dispatch
}


val acc = make-account 100

;; acc @withdraw <| 50
# -> &Ok 50
;; acc @withdraw <| 60
# -> &Err "Insufficient funds"
;; acc @deposit <| 40
# -> 90
;; acc @withdraw <| 60
# -> 30



#### 3.1.2 The Benefits of Introducing Assignment
#### 3.1.2 代入を取り入れた利点 -- p131

;; print "\n\nSECTION 3.1.2"
;;



#### 3.1.3 The Costs of Introducing Assignment
#### 3.1.3 代入を取り入れた代価 -- p134

;; print "\n\nSECTION 3.1.3"
;;

fun make-simplified-withdraw = balance -> let {
    val ref-balance = ref balance
in  {
        amount
    -> do (
            ! ref-balance := !!ref-balance - amount
            ! !!ref-balance
        )
    }
}

val W = make-simplified-withdraw 25

;; W 20
# -> 5
;; W 10
# -> -5
;;


fun make-decrementer = balance -> {
    amount
->
    balance - amount
}

val D = make-decrementer 25

;; D 20
# -> 5
;; D 10
# -> 15
;;



#### 3.2 The Environment Model of Evaluation
#### 3.2 評価の環境モデル -- p138

;; print "\n\nSECTION 3.2"
;;



#### 3.2.1 The Rules for Evaluation
#### 3.2.1 評価の規則 -- p138

;; print "\n\nSECTION 3.2.1"
;;



#### 3.2.2 Applying Simple Procedures
#### 3.2.2 単純な手続きの作用 -- p140

;; print "\n\nSECTION 3.2.2"
;;



#### 3.2.3 Frames as the Repository of Local State
#### 3.2.3 局所状態の入れ物としてのフレーム -- p142

;; print "\n\nSECTION 3.2.3"
;;



#### 3.2.4 Internal Definitions
#### 3.2.4 内部定義 -- p145

;; print "\n\nSECTION 3.2.4"
;;



#### 3.3 Modeling with Mutable Data
#### 3.3 可変データでのモデル化 -- p147

;; print "\n\nSECTION 3.3"
;;



#### 3.3.1 Mutable List Structure
#### 3.3.1 可変リスト構造 -- p147

;; print "\n\nSECTION 3.3.1"
;;



#### 3.3.2 Representing Queues
#### 3.3.2 キューの表現 -- p153

;; print "\n\nSECTION 3.3.2"
;;



#### 3.3.3 Representing Tables
#### 3.3.3 表の表現 -- p156

;; print "\n\nSECTION 3.3.3"
;;

###     assoc : Symbol -> [(Symbol, 'a)] -> Option (Symbol, 'a)
fun rec assoc = (key : Symbol) (records : SExpr) -> cond records of {
| SE::Nil? -> NONE
| SE::Atom? -> panic! <| "Unexpected atom: " ^ records.show
| SE::Cons? -> let {
        val (car: cdr:) = val-of records
    in
        if SE::Cons? car then let {
            val (car:car' cdr:cdr') = val-of car
        in
            if key == val-of car' then
                Some car
            else
                assoc key cdr
        } else
            assoc key cdr
    }
}


### lookup1 = Symbol -> <TABLE> [(Symbol, 'a)] -> Option 'a
fun lookup1 = key table -> let {
    val opt-record  = assoc key <| SE::cdr table
in
    case opt-record of {
    | &Some cons -> Some <| SE::cdr cons
    | &None      -> NONE
    }
}


fun insert! = key value table -> do (
    ! let {
        val (_, ref-records) = table
        val opt-record  = assoc key <| !!ref-records
    in
        case opt-record of {
        | &Some record -> ref-records := record value 
        | &None        -> set-cdr! table 
        }
    }

    ! @ok
)

fun make-table = records : List -> (SE::cons
    (SE::cons
        (SE::atom @"*table*")
        SE::NIL
    )

    (records |> foldr SE::NIL { (k, v) se ->
            SE::cons
                (SE::cons (SE::atom k) v)
                se
        }
    )
)




;; val t1 = make-table [
    (@a, (SE::atom 1)),
    (@b, (SE::atom 2)),
    (@c, (SE::atom 3))
]
(#
    a:  1
    b:  2
    c:  3
#)

;; t1
# -> ((@*table*) (@a . 1) (@b . 2) (@c . 3))

;; lookup1 @b t1
# -> &Some 2

;; lookup1 @d t1
# -> &None ()
;;


#### two-dimensional ####

(### lookup2 = Symbol ->
                Symbol ->
                <TABLE> [(Symbol, [(Symbol, 'a)])] ->
                Option 'a
###)
fun lookup2 = key1 key2 table -> let {
    val opt-subtable = assoc key1 (SE::cdr table)
in
    if Some? opt-subtable then let {
        val opt-record = assoc key2 (SE::cdr (val-of opt-subtable))
    in
        if Some? opt-record then Some (SE::cdr (val-of opt-record))
                            else NONE
    } else NONE
}


;; val t2 = make-table [
                (@math,
                    (SE::make
                        [
                            (SE::cons (SE::atom @"+") (SE::atom 43)),
                            (SE::cons (SE::atom @"-") (SE::atom 45)),
                            (SE::cons (SE::atom @"*") (SE::atom 42))
                        ]
                    )
                ),

                (@letters,
                    (SE::make
                        [
                            (SE::cons (SE::atom @a) (SE::atom 97)),
                            (SE::cons (SE::atom @b) (SE::atom 98))
                        ]
                    )
                )
            ]
(#
    math:
        +: 43
        -: 45
        *: 42
    letters:
        a: 97
        b: 98
#)

;; t2
# -> (
#    (@*table*)
#    (@math (@+ . 43) (@- . 45) (@* . 42))
#    (@letters (@a . 97) (@b . 98))
# )


;; lookup2 @math @"-" t2
# -> &Some 45

;; lookup2 @letters @a t2
# -> &Some 97

;; lookup2 @nath @"-" t2
# -> &None ()

;; lookup2 @math @"/" t2
# -> &None ()
;;


#### local tables ####

fun make-table' = records -> let {
    val local-table = make-table records

    fun lookup = key1 key2 -> let {
        val opt-subtable = assoc key1 (SE::cdr local-table)
    in
        if Some? opt-subtable then let {
            val opt-record = assoc key2 (SE::cdr (val-of opt-subtable))
        in
            if Some? opt-record then Some (SE::cdr (val-of opt-record))
                                else NONE
        } else NONE
    }

    fun dispatch = m -> case m of {
    | @lookup-proc -> lookup
    else           -> panic! <| "Unknown operation -- TABLE: " ^ show m
    }
in
    dispatch
}

val operation-table = make-table' [
                    (@math,
                        (SE::make
                            [
                                (SE::cons (SE::atom @"+") (SE::atom 43)),
                                (SE::cons (SE::atom @"-") (SE::atom 45)),
                                (SE::cons (SE::atom @"*") (SE::atom 42))
                            ]
                        )
                    ),

                    (@letters,
                        (SE::make
                            [
                                (SE::cons (SE::atom @a) (SE::atom 97)),
                                (SE::cons (SE::atom @b) (SE::atom 98))
                            ]
                        )
                    )
                ]

val get = operation-table @lookup-proc


;; operation-table
# -> #<dispatch: ....>

;; get
# -> #<lookup: ....>

;; get @math @"-"
# -> &Some 45

;; get @letters @a
# -> &Some 97

;; get @nath @"-"
# -> &None ()

;; get @math @"/"
# -> &None ()
;;

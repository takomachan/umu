(#
    データベース・システム概論 第三版, 1984年,
        C.J.Date著, 藤原譲訳, 丸善株式会社


    ここでは、識別子(いわゆる変数名)としてかな/漢字を用いた例を示す。

    想定する用途は、SQLコードの実装段階ではなく、上流の抽象的な
    データモデル設計段階の成果物である。一般にこうした仕様書の大半は、
    非形式的で曖昧な自然語(日本語)で記述され、当然そこには：
      ＊ 単純なスペルミス
      ＊ 定義されていない概念の参照
      ＊ 定義されているがどこからも参照されない宙ぶらりんな概念
      ＊ 定義のゆらぎ
      ＊ 判定条件の漏れ
    といった誤り(エラー)が含まれる。その結果、仕様書を渡された下流工程の
    担当者は悪戦苦闘し疲弊する。それだけではない。テスト工程で摘出された
    誤り(バグ)作り込みの所在は下流工程担当者として品質管理上では記録され、
    誤りが多発すれば、やれこんな単純なロジックの実装をミスった、やれ
    彼は実装能力のレベルが低い、などと批判のまとにされる。根本原因は、
    上流工程の仕様書の曖昧さであるにもかかわらず、だ。

    こうした問題は、上流工程の仕様を簡潔で明瞭な関数型言語で
    記述することによって低減できると考える。スペルミスや未定義といった
    仕様書の誤りの多くは、言語処理系を適用することによって検出できる。
    また「動く仕様(walkable specification)」として、仕様定義者/実装担当者の
    仕様に対する理解度を高めることができる。

    もしあなたの担当業務が上流工程であり自己の仕様定義能力に自信があるなら、
    一度、関数型言語で仕様を記述してみよう。簡単にできるはずだ。
    開発の途中で顧客から仕様追加を要求されても、安易に了解するなかれ。
    まず記述コードを更新して動かし、追加仕様の実現性や必要コストを塾考する。

    もしあなたの担当業務が下流工程であるなら、あわててモジュール/クラス設計
    といった実装設計へとりかかる前に、渡された仕様書の内容を関数型言語で
    記述して動かしてみよう。もし結果が意図しない振る舞いであったなら、
    その問題を整理してから上流工程の担当者へ報告すればいい。
    仕様書の誤り(バグ)ではないですか？と。

    本プロジェクトには、問題解決水準の向上を目的に以下の計画(妄想？)がある。
      ＊ 関数型記述からDocBook文書の自動生成
      ＊ 次元解析/単位解析による表現力とエラー検出能力の向上
      ＊ 静的型付け技術を元にした型検査器の提供


    2024年7月3日, takomachan記
#)


structure UAS = Umu::Assert


# 3 データ構造および対応する演算子 -- p65

# 3.2 関係型の方法 -- p66

structure 関係型データモデル-3 = struct {
    structure 納入業者表 = 納入業者表
    structure 部品表     = 部品表
    structure 出荷表     = 出荷表
} where {
    structure 納入業者表 = struct {
        fun 納入業者番号 = 桁 : Product -> 桁$1
        fun 業者名       = 桁 : Product -> 桁$2
        fun 状態コード   = 桁 : Product -> 桁$3
        fun 所在地       = 桁 : Product -> 桁$4

        val 桁リスト = map { 桁 -> (
                納入業者番号: 納入業者番号 桁,
                業者名:       業者名       桁,
                状態コード:   状態コード   桁,
                所在地:       所在地       桁
            )
        } [
        #    納入業者番号  業者名     状態コード  所在地
        #------------------------------------------------------
            (@S1,         "スミス",   20,        "ロンドン"),
            (@S2,         "ジョン",   10,        "パリ"),
            (@S3,         "ブラーク", 30,        "パリ")
        ]
    }


    structure 部品表 = struct {
        fun 部品番号 = 桁 : Product -> 桁$1
        fun 部品名   = 桁 : Product -> 桁$2
        fun 色       = 桁 : Product -> 桁$3
        fun 重量     = 桁 : Product -> 桁$4
        fun 納入場所 = 桁 : Product -> 桁$5

        val 桁リスト = map { 桁 -> (
                部品番号: 部品番号 桁,
                部品名:   部品名   桁,
                色:       色       桁,
                重量:     重量     桁,
                納入場所: 納入場所 桁
            )
        } [
        #    部品番号  部品名    色   重量  納入場所
        #------------------------------------------------
            (@P1,     "ナット", "赤", 12,  "ロンドン"),
            (@P2,     "ボルト", "緑", 17,  "パリ"),
            (@P3,     "ねじ",   "青", 17,  "ローマ"),
            (@P4,     "ねじ",   "赤", 14,  "ロンドン")
        ]
    }


    structure 出荷表 = struct {
        fun 納入業者番号 = 桁 : Tuple -> 桁$1
        fun 部品番号     = 桁 : Tuple -> 桁$2
        fun 出荷量       = 桁 : Tuple -> 桁$3

        val 桁リスト = map { 桁 -> (
                納入業者番号: 納入業者番号 桁,
                部品番号:     部品番号     桁,
                出荷量:       出荷量       桁
            )
        } [
        #    納入業者番号  部品番号  出荷量
        #------------------------------------
            (@S1,          @P1,      300),
            (@S1,          @P2,      200),
            (@S1,          @P3,      400),
            (@S2,          @P1,      300),
            (@S2,          @P2,      400),
            (@S2,          @P2,      200)
        ]
    }
}



import 関係型データモデル-3 {
    structure 納入業者表
    structure 部品表
    structure 出荷表
}

;;



# 3.5 高水準演算子 -- p75

# 3.5.1 Find CITY for supplier S1.
# 3.5.1 納入業者 S1 に対して所在地を見つけること。

print "#### 3.5.1 ####" ;;
pp [|所在地|
    val (納入業者番号:, 所在地:) <- 納入業者表::桁リスト
    if 納入業者番号 == @S1
] ;;
# --> ["ロンドン"]
nl () ;;


# 3.5.2 パリにある納入業者に対して 納入業者番号と状態コードを見つけること。

print "#### 3.5.2 ####" ;;
pp [|納入業者番号:, 状態コード:|
    val (納入業者番号:, 状態コード:, 所在地:) <- 納入業者表::桁リスト

    if 所在地 == "パリ"
] ;;
# --> [(納入業者番号: @S2, 状態コード: 10), (納入業者番号: @S3, 状態コード: 30)]
nl () ;;


# 3.5.3 納入業者 S1 から納入される部品に対して部品名を見つけること。

print "#### 3.5.3 ####" ;;
pp [|部品名|
    val (納入業者番号:, 部品番号: 出荷表の部品番号) <- 出荷表::桁リスト
    if 納入業者番号 == @S1

    val (部品名:,       部品番号: 部品表の部品番号) <- 部品表::桁リスト

    if 出荷表の部品番号 == 部品表の部品番号 
] ;;
# --> ["ナット", "ボルト", "ねじ"]
nl () ;;


# 3.5.4 納入される各部品に対して、部品番号およびその部品を納入している
#       すべての都市の名前を見つけること。

print "#### 3.5.4 ####" ;;
pp [|部品番号:, 都市名: 所在地|
    val (納入業者番号: 出荷表の納入業者番号, 部品番号:) <-
                                                     出荷表::桁リスト
    val (納入業者番号: 業者表の納入業者番号, 所在地:)   <-
                                                     納入業者表::桁リスト

    if 出荷表の納入業者番号 == 業者表の納入業者番号
] ;;
# --> [
#     (部品番号: @P1, 都市名: "ロンドン"),
#     (部品番号: @P2, 都市名: "ロンドン"),
#     (部品番号: @P3, 都市名: "ロンドン"),
#     (部品番号: @P1, 都市名: "パリ"),
#     (部品番号: @P2, 都市名: "パリ"),
#     (部品番号: @P2, 都市名: "パリ")
# ]
nl () ;;

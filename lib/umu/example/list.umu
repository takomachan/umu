module LIST = struct {
	# head : ['a] -> 'a
	fun head = xs -> (des xs).1


	# tail : ['a] -> ['a]
	fun tail = xs -> (des xs).2


	# singleton : 'a -> ['a]
	fun singleton = x -> [x]


	# singleton? : ['a] -> BOOL
	fun singleton? = xs -> cond xs {
	  empty?	-> FALSE
	| otherwise	-> empty? xs'
		where val [_|xs'] = xs
	}


	# equal? : ('a -> 'b -> BOOL) -> 'A -> 'B -> BOOL
	(#
		where, if
		* 'A is a List and 'a is element of 'A
		* 'B is a List and 'b is element of 'B
		* equal 'a to 'b
		then TRUE, else FALSE
	#)
	fun rec equal? = eq? xs ys ->
		if (xs ako? List andalso ys ako? List)
			if (empty? xs)
				empty? ys
			else
				if (empty? ys)
					FALSE
				else let {
					val [x|xs'] = xs
					val [y|ys'] = ys
				in
					eq? x y andalso equal? eq? xs' ys'
				}
		else
			FALSE


	# fold : 'b -> ('a -> 'b -> 'b) -> ['a] -> 'b
	fun rec fold = a f xs -> cond xs {
	  empty?	-> a
	| otherwise	-> fold (f x a) f xs'
		where val [x|xs'] = xs
	}


	# foldr : 'b -> ('a -> 'b -> 'b) -> ['a] -> 'b
	fun rec foldr = a f xs -> cond xs {
	  empty?	-> a
	| otherwise	-> f x (foldr a f xs')
		where val [x|xs'] = xs
	}


	# foldl : 'b -> ('b -> 'a -> 'b) -> ['a] -> 'b
	fun rec foldl = a f xs -> cond xs {
	  empty?	-> a
	| otherwise	-> foldl (f a x) f xs'
		where val [x|xs'] = xs
	}


	# length : ['a] -> INT
	fun rec length = xs -> cond xs {
	  empty?	-> 0
	| otherwise	-> length xs' + 1
		where val [_|xs'] = xs
	}

	val length' = fold 0 { _ len -> len + 1 }


	# sum : [INT] -> INT
	fun rec sum = xs -> cond xs {
	  empty?	-> 0
	| otherwise	-> x + sum xs'
		where val [x|xs'] = xs
	}

	val sum' = fold 0 (+)


	# map : ('a -> 'b) -> ['a] -> ['b]
	fun rec map = f xs -> cond xs {
	  empty?	-> []
	| otherwise	-> [f x | map f xs']
		where val [x|xs'] = xs
	}

	fun map' = f -> foldr [] { x xs -> [f x | xs] }


	# filter : ('a -> BOOL) -> ['a] -> ['a]
	fun rec filter = f xs -> cond xs {
	  empty?	-> []
	| otherwise	-> if (f x)
							[x|xs'']
						else
							xs''
		where
			val [x|xs'] = xs
			val xs'' = filter f xs'
	}

	fun filter' = f -> foldr [] { x xs -> if (f x) [x|xs] else xs }


	# append : ['a] -> ['a] -> ['a]
	fun rec append = xs ys ->
		if (empty? xs)
			ys
		else if (empty? ys)
			xs
		else let {
			val [x|xs'] = xs
		in
			[x | append xs' ys]
		}

	fun append' = xs ys -> foldr ys cons xs
	val append'' = (++)


	# concat : [['a]] -> ['a]
	fun rec concat = xss -> cond xss {
	  empty?	-> []
	| otherwise	-> xs ++ concat xss'
		where val [xs|xss'] = xss
	}

	val concat'  = fold  [] { xs xss -> xss ++ xs }
	val concat'' = foldr [] (++)


	# join-string : STRING -> [STRING] -> STRING
	fun join-string = j xs -> cond xs {
	  empty?	-> ""
	| otherwise	-> if (empty? xs')
							x
						else
							x ^ fold "" { x' s -> s ^ j ^ x' } xs'
		where val [x|xs'] = xs
	}


	# reverse : ['a] -> ['a]
	fun rec reverse = xs -> cond xs {
	  empty?	-> []
	| otherwise	-> reverse xs' ++ [x]
		where val [x|xs'] = xs
	}

	val reverse' = rev []
	where {
		fun rec rev = a xs -> cond xs {
		  empty?	-> a
		| otherwise	-> rev [x|a] xs'
			where val [x|xs'] = xs
		}
	}

	val reverse'' = fold [] cons


	# zip : ['a] -> ['b] -> [('a, 'b)]
	fun rec zip = xs ys ->
		if (empty? xs)
			ys
		else if (empty? ys)
			xs
		else let {
			val [x|xs'] = xs
			val [y|ys'] = ys
		in
			[(x, y) | zip xs' ys']
		}

	val zip' = foldr (const []) f
	where {
		fun f = x g ys -> cond ys {
		  empty?	-> []
		| otherwise	-> [(x, y) | g ys']
			where val (y, ys') = ys.des
		}
	}


	# unzip : [('a, 'b)] -> (['a], ['b])
	fun rec unzip = xs -> cond xs {
	  empty?	-> ([], [])
	| otherwise	-> ([y|ys'], [z|zs'])
		where
			val [pair|xs']	= xs
			val (y, z)		= pair
			val (ys', zs')	= unzip xs'
	}

	val unzip' = foldr ([], []) { (y, z) (ys, zs) -> ([y|ys], [z|zs]) }


	# partition : ('a -> BOOL) -> ['a] -> (['a], ['a])
	fun rec partition = f xs -> cond xs {
	  empty?	-> ([], [])
	| otherwise	-> if (f x)
						([x|ys],    zs)
					else
						(   ys,  [x|zs])
		where
			val [x|xs']  = xs
			val (ys, zs) = partition f xs'
	}

	fun partition' = f -> foldr ([], []) { x (ys, zs) ->
		if (f x)
			([x|ys],    zs)
		else
			(   ys,  [x|zs])
	}


	# sort : ('a -> 'a -> BOOL) -> ['a] -> ['a]
	fun rec sort = lt? xs -> cond xs {
	  empty?	-> []
	| otherwise	-> sort lt? littles ++ [pivot] ++ sort lt? bigs
		where
			val [pivot|xs']		= xs
			val (littles, bigs)	= partition { x -> lt? x pivot } xs'
	}
} where {
	module struct {
		val (Empty? => empty?, Cons => cons, des)
	} = UMU::LIST
}

;;



# See: PythonでもRubyみたいに配列をメソッドチェーンでつなげたい
# 		https://edvakf.hatenadiary.org/entry/20090405/1238885788

val sort	= LIST::sort (<)
val reverse	= LIST::reverse
val map		= LIST::map
val join	= LIST::join-string

;;

#### 1. Pipeline Style (Like a F#, Ocaml, Elixir)

[1, 4, 3, 2] ;;
# -> [1, 4, 3, 2]

[1, 4, 3, 2] |> sort ;;
# -> [1, 2, 3, 4]

[1, 4, 3, 2] |> sort |> reverse ;;
# -> [4, 3, 2, 1]

[1, 4, 3, 2] |> sort |> reverse |> map to-s ;;
# -> ["4", "3", "2", "1"]

[1, 4, 3, 2] |> sort |> reverse |> map to-s |> join "-" ;;
# -> "4-3-2-1"


#### 1'. Another Pipeline Style (Like a Haskell's $-operator)
join "-" <| map to-s <| reverse <| sort <| [1, 4, 3, 2] ;;
# -> "4-3-2-1"


#### 2. Composition Style
(sort >> reverse >> map to-s >> join "-") [1, 4, 3, 2] ;;
# or
[1, 4, 3, 2] |> sort >> reverse >> map to-s >> join "-" ;;
# -> "4-3-2-1"


#### 2'. Another Composition Style (Like a Haskell's Point-free style)
(join "-" << map to-s << reverse << sort) [1, 4, 3, 2] ;;
# or
join "-" << map to-s << reverse << sort <| [1, 4, 3, 2] ;;
# -> "4-3-2-1"


#### 3. Classical Style (Like a LISP, Python, ... etc)
join "-" (map to-s (reverse (sort [1, 4, 3, 2]))) ;;
# -> "4-3-2-1"

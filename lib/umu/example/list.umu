module LIST = struct {
	# head : ['a] -> 'a
	fun head = xs -> x where { val [x|_] = xs }


	# tail : ['a] -> ['a]
	fun tail = xs -> xs' where { val [_|xs'] = xs }


	# singleton : 'a -> ['a]
	fun singleton = x -> [x]


	# singleton? : ['a] -> BOOL
	fun singleton? = xs -> cond xs {
		empty?	=> FALSE
		else	=> empty? xs'
					where val [_|xs'] = xs
	}


	# equal? : ('a -> 'b -> BOOL) -> 'A -> 'B -> BOOL
	(#
		where, if
		* 'A is a List and 'a is element of 'A
		* 'B is a List and 'b is element of 'B
		* equal 'a to 'b
		then TRUE, else FALSE
	#)
	fun rec equal? = eq? xs ys ->
		if (xs ako? List andalso ys ako? List)
			cond xs {
				empty?	=> empty? ys
				else	=> cond ys {
					empty?	=> FALSE
					else	=> eq? x y andalso equal? eq? xs' ys'
								where	val [x|xs'] = xs
										val [y|ys'] = ys
				}
			}
		else
			FALSE


	# fold : 'b -> ('a -> 'b -> 'b) -> ['a] -> 'b
	fun rec fold = a f xs -> cond xs {
		empty?	=> a
		else	=> fold (f x a) f xs'
					where val [x|xs'] = xs
	}


	# foldr : 'b -> ('a -> 'b -> 'b) -> ['a] -> 'b
	fun rec foldr = a f xs -> cond xs {
		empty?	=> a
		else	=> f x (foldr a f xs')
					where val [x|xs'] = xs
	}


	# foldl : 'b -> ('b -> 'a -> 'b) -> ['a] -> 'b
	fun rec foldl = a f xs -> cond xs {
		empty?	=> a
		else	=> foldl (f a x) f xs'
					where val [x|xs'] = xs
	}


	# length : ['a] -> INT
	fun rec length = xs -> cond xs {
		empty?	=> 0
		else	=> length xs' + 1
					where val [_|xs'] = xs
	}

	val length' = fold 0 { _ len -> len + 1 }


	# sum : [INT] -> INT
	fun rec sum = xs -> cond xs {
		empty?	=> 0
		else	=> x + sum xs'
					where val [x|xs'] = xs
	}

	val sum' = fold 0 (+)


	# map : ('a -> 'b) -> ['a] -> ['b]
	fun rec map = f xs -> cond xs {
		empty?	=> []
		else	=> [f x | map f xs']
					where val [x|xs'] = xs
	}

	fun map' = f -> foldr [] { x xs -> [f x | xs] }


	# filter : ('a -> BOOL) -> ['a] -> ['a]
	fun rec filter = f xs -> cond xs {
		empty?	=> []
		else	=> if (f x) [x|xs''] else xs''
					where	val [x|xs'] = xs
							val xs'' = filter f xs'
	}

	fun filter' = f -> foldr [] { x xs -> if (f x) [x|xs] else xs }


	# append : ['a] -> ['a] -> ['a]
	fun rec append = xs ys -> cond xs {
		empty?	=> ys
		else	=> cond ys {
			empty?	=> xs
			else	=> [x | append xs' ys]
						where val [x|xs'] = xs
		}
	}

	fun append' = xs ys -> foldr ys cons xs
	val append'' = (++)


	# concat : [['a]] -> ['a]
	fun rec concat = xss -> cond xss {
		empty?	=> []
		else	=> xs ++ concat xss'
					where val [xs|xss'] = xss
	}

	val concat'  = fold  [] { xs xss -> xss ++ xs }
	val concat'' = foldr [] (++)


	# join-string : STRING -> [STRING] -> STRING
	fun join-string = j xs -> cond xs {
		empty?	=> ""
		else	=> cond xs' {
			empty?	=> x
			else	=> x ^ fold "" { x' s -> s ^ j ^ x' } xs'
		} where val [x|xs'] = xs
	}


	# reverse : ['a] -> ['a]
	fun rec reverse = xs -> cond xs {
		empty?	=> []
		else	=> reverse xs' ++ [x]
					where val [x|xs'] = xs
	}

	val reverse' = rev []
	where {
		fun rec rev = a xs -> cond xs {
			empty?	=> a
			else	=> rev [x|a] xs'
						where val [x|xs'] = xs
		}
	}

	val reverse'' = fold [] cons


	# zip : ['a] -> ['b] -> [('a, 'b)]
	fun rec zip = xs ys -> cond xs {
		empty?	=> ys
		else	=> cond ys {
			empty?	=> xs
			else	=> [(x, y) | zip xs' ys']
						where	val [x|xs'] = xs
								val [y|ys'] = ys
		}
	}

	val zip' = foldr (const []) f
	where {
		fun f = x g ys -> cond ys {
			empty?	=> []
			else	=> [(x, y) | g ys']
						where val [y|ys'] = ys
		}
	}


	# unzip : [('a, 'b)] -> (['a], ['b])
	fun rec unzip = xs -> cond xs {
		empty?	=> ([], [])
		else	=> ([y|ys'], [z|zs'])
					where	val [pair|xs']	= xs
							val (y, z)		= pair
							val (ys', zs')	= unzip xs'
	}

	val unzip' = foldr ([], []) { (y, z) (ys, zs) -> ([y|ys], [z|zs]) }


	# partition : ('a -> BOOL) -> ['a] -> (['a], ['a])
	fun rec partition = f xs -> cond xs {
		empty?	=> ([], [])
		else	=> if (f x)
						([x|ys],    zs)
					else
						(   ys,  [x|zs])
					where	val [x|xs']  = xs
							val (ys, zs) = partition f xs'
	}

	fun partition' = f -> foldr ([], []) { x (ys, zs) ->
		if (f x)
			([x|ys],    zs)
		else
			(   ys,  [x|zs])
	}


	# sort : ('a -> 'a -> BOOL) -> ['a] -> ['a]
	fun rec sort = lt? xs -> cond xs {
		empty?	=> []
		else	=> sort lt? littles ++ [pivot] ++ sort lt? bigs
					where	val [pivot|xs']		= xs
							val (littles, bigs)	=
										partition { x -> lt? x pivot } xs'
	}
} where {
	module struct {
		val (Empty? => empty?, Cons => cons)
	} = UMU::LIST
}

;;



# See: PythonでもRubyみたいに配列をメソッドチェーンでつなげたい
# 		https://edvakf.hatenadiary.org/entry/20090405/1238885788

val sort	= LIST::sort (<)
val reverse	= LIST::reverse
val map		= LIST::map
val join	= LIST::join-string

;;

#### 1. Pipeline Style (Like a F#, Ocaml, Elixir)

[1, 4, 3, 2] ;;
# -> [1, 4, 3, 2]

[1, 4, 3, 2] |> sort ;;
# -> [1, 2, 3, 4]

[1, 4, 3, 2] |> sort |> reverse ;;
# -> [4, 3, 2, 1]

[1, 4, 3, 2] |> sort |> reverse |> map to-s ;;
# -> ["4", "3", "2", "1"]

[1, 4, 3, 2] |> sort |> reverse |> map to-s |> join "-" ;;
# -> "4-3-2-1"


#### 1'. Another Pipeline Style (Like a Haskell's $-operator)
join "-" <| map to-s <| reverse <| sort <| [1, 4, 3, 2] ;;
# -> "4-3-2-1"


#### 2. Composition Style
(sort >> reverse >> map to-s >> join "-") [1, 4, 3, 2] ;;
# or
[1, 4, 3, 2] |> sort >> reverse >> map to-s >> join "-" ;;
# -> "4-3-2-1"


#### 2'. Another Composition Style (Like a Haskell's Point-free style)
(join "-" << map to-s << reverse << sort) [1, 4, 3, 2] ;;
# or
join "-" << map to-s << reverse << sort <| [1, 4, 3, 2] ;;
# -> "4-3-2-1"


#### 3. Classical Style (Like a LISP, Python, ... etc)
join "-" (map to-s (reverse (sort [1, 4, 3, 2]))) ;;
# -> "4-3-2-1"

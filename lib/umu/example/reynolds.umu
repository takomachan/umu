(#
 Implementation of REYNOLDS's Definional Interpretor
 1971年に公開されたレイノルズ氏による意味定義用インタプリタをUmuで実装してみた


 Reynolds, J. C. :
   Definitional Interpretors
   for Higher-Oreder Programming Languages,
   Higer-Order and Symbolic Computation, 11, 363-397 (1998),
   Proceedings of 25h ACM National Conference, 1971, pp. 717-740

 木村泉, 米澤明憲 :
   第9章 算法表現(プログラム)の意味論,
   算法表現論, 岩波講座情報科学12, 岩波書店, 1982

	   上記論文のInterpreter I と II を元にして
	   プログラミング言語の古典的な意味論を解説している
	   なお、現在のUmu言語処理系(インタプリタ)は
	   この Interpreter II を元に設計された


 Exanple execution :
 実行例 :
	$ ./umu -i example/reynolds.umu
	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	[CONSTANT]
	<SRC> : 100
	<EXP> : Const 100
	-> <VAL> : Integer 100
			:
			:
			:
	0001> run-I [ADD, 1, 2]
	      ^^^^^^^^^^^^^^^^^
	<SRC> : [@ADD, 1, 2]
	<EXP> : Appl (Appl (Var @ADD, Const 1), Const 2)
	-> <VAL> : Integer 3
	
	-> Integer 3 : Datum
	0002>
#)



######## Error Handler ########

structure ERROR = struct {
	# failure		: String -> 'a -> ()
	fun failure		= msg x -> error ("Assertion Failure",	msg, x)

	# syntax		: String -> 'a -> ()
	fun syntax		= msg x -> error ("Syntax Error",		msg, x)

	# name			: String -> 'a -> ()
	fun name		= msg x -> error ("Name Error",			msg, x)

	# application	: String -> 'a -> ()
	fun application	= msg x -> error ("Application Error",	msg, x)

	# type'			: String -> 'a -> ()
	fun type'		= msg x -> error ("Type Error",			msg, x)
} where {
	fun error = (category, msg, x) ->
		abort ("[" ^ category ^ "] " ^ msg ^ inspect x)
}



(######## Expression ########

<EXP> = <CONST> + <VAR> + <APPL> + <LAMBDA> + <COND> + <LETREC>

<APPL>   = [opr: <EXP>, opnd: <EXP>]
<LAMBDA> = [fp: <VAR>, body: <EXP>]
<COND>   = [prem: <EXP>, conc: <EXP>, altr: <EXP>]
<LETREC> = [dvar: <VAR>, dexp: <LAMBDA>, body: <EXP>]

############################)

structure EXP = struct {
	#### Constructor ####

	# mk-const : Integer -> <CONST>
	fun mk-const = x -> Datum @Const x

	# mk-var : Atom -> <VAR>
	fun mk-var = x -> Datum @Var x

	# mk-appl : (<EXP>, <EXP>) -> <APPL>
	fun mk-appl = (opr, opnd) -> Datum @Appl (opr, opnd)

	# mk-lambda : (<VAR>, <EXP>) -> <LAMBDA>
	fun mk-lambda = (fp, body) -> Datum @Lambda (fp, body)

	# mk-cond : (<EXP>, <EXP>, <EXP>) -> <COND>
	fun mk-cond = (prem, conc, altr) -> Datum @Cond (prem, conc, altr)

	# mk-letrec : (<VAR>, <LAMBDA>, <EXP>) -> <LETREC>
	fun mk-letrec = (dvar, dexp, body) -> Datum @Letrec (dvar, dexp, body)


	#### Classifier ####

	# const? : <EXP> -> Bool
	fun const? = exp -> tag-of exp == @Const

	# var? : <EXP> -> Bool
	fun var? = exp -> tag-of exp == @Var

	# appl? : <EXP> -> Bool
	fun appl? = exp -> tag-of exp == @Appl

	# lambda? : <EXP> -> Bool
	fun lambda? = exp -> tag-of exp == @Lambda

	# cond? : <EXP> -> Bool
	fun cond? = exp -> tag-of exp == @Cond

	# letrec? : <EXP> -> Bool
	fun letrec? = exp -> tag-of exp == @Letrec
}



(######## Value ########

<VAL> = <INTEGER> + <BOOLEAN> + <FUNVAL>

################)

structure VAL = struct {
	#### Constructor ####

	# Integer -> <INTEGER>
	fun mk-integer = x -> Datum @Integer x

	# Bool -> <BOOLEAN>
	fun mk-boolean = x -> Datum @Boolean x

	# Function -> <FUNVAL>
	fun mk-funval = x -> Datum @Funval x


	#### Classifier ####

	# <VAL> -> Bool
	fun integer? = exp -> tag-of exp == @Integer

	# <VAL> -> Bool
	fun boolean? = exp -> tag-of exp == @Boolean

	# <VAL> -> Bool
	fun funval?	 = exp -> tag-of exp == @Funval
}



(######## Parser ########

 <Exp> ::= <Const>	/* Undefined, Umu's Integer */
         | <Var>	/* Undefined, Umu's Atom */
		 | <Form>


 <Form> ::= <If> | <Lambda> | <Apply> | <Let> | <Letrec>



 <If>     ::= "[" IF "," <Exp> "," <Exp> "," <Exp> "]"


 <Lambda> ::= "[" LAMBDA "," "[" <Var1> "," ... "," <VarN> "]" "," <Exp> "]"
 																/* N >= 1 */

 <Apply>  ::= "[" <Exp1> "," ... "," <ExpN> "]"  /* N >= 2 */


 <Let>    ::= "[" LET "," <Exp> "," <ValBind1> "," ... "," <ValBindN> "]"
 <ValBind> ::= "[" <Var> "," <Exp> "]"							/* N >= 0 */


 <Letrec> ::= "[" LETREC "," <Exp> "," <LamBind1> "," ... "," <LamBindN> "]"
 <LamBind> ::= "[" <Var> "|" <Lambda> "]"						/* N >= 0 */

########################)

# parse : 'a -> <EXP>
fun rec parse = exp -> cond exp {
  const?	-> EXP::mk-const exp
| var?		-> EXP::mk-var exp
| form?		-> parse-form exp
  else		-> ERROR::syntax "Unknown Expression: " exp
} where {
	# const? : 'a -> Bool
	fun const? = exp -> exp isa? Integer

	# var? : 'a -> Bool
	fun var? = exp -> exp isa? Atom

	# form? : 'a -> Bool
	fun form? = exp -> exp isa? List andalso length exp >= 2



	#### <Form> ####
	# parse-form : ['a] -> <EXP>
	fun parse-form = exp -> let {
		val [keyword|args] = exp
	in
		if (keyword isa? Atom)
			cond keyword {
			  (== @IF)		-> parse-if		args
			| (== @LAMBDA)	-> parse-lambda	args
			| (== @LET)		-> parse-let	args
			| (== @LETREC)	-> parse-letrec	args
			  else			-> parse-apply	exp
			}
		else
			parse-apply	exp
	} where {
		#### <If> ####
		# parse-if : ['a] -> <COND>
		fun parse-if = args -> let {
			assert (length args == 3)
				ERROR::syntax "For IF's arity, expected 3, but: " args

			val [prem, conc, altr] = args
		in
			EXP::mk-cond (parse prem, parse conc, parse altr)
		}

		#### <Lambda> ####
		# parse-lambda : ['a] -> <LAMBDA>
		fun parse-lambda = args -> let {
			assert (length args == 2)
				ERROR::syntax 
					"For LAMBDA's arity, expected 2, but: " args

			val [fps, body] = args

			assert (fps isa? List)
				ERROR::syntax
					"In LAMBDA, expected a List of <Var>, but: " fps
			assert (length fps >= 1)
				ERROR::syntax
					("In LAMBDA, " ^
						"expected length of <Var>s is 1 or more, but: ")
					fps

			val [init-fp|fps'] = reverse fps

			assert (var? init-fp)
				ERROR::syntax "In LAMBDA, expected a <Var>, but: " init-fp

			val init-body-exp = EXP::mk-lambda (parse init-fp, parse body)
		in
			fps' |> foldl init-body-exp { fp body-exp ->
				let {
					assert (var? fp)
						ERROR::syntax "In LAMBDA, expected a <Var>, but: "
						fp
				in
					EXP::mk-lambda (parse fp, body-exp)
				}
			}
		}

		#### <Apply> ####
		# parse-apply : ['a] -> <APPL>
		fun parse-apply = form -> let {
			val [opr, init-opnd|opnds] = form
			val init-opr-exp = EXP::mk-appl (parse opr, parse init-opnd)
		in
			opnds |> foldl init-opr-exp { opnd opr-exp ->
				EXP::mk-appl (opr-exp, parse opnd)
			}
		}

		#### <Let> ####
		# parse-let : ['a] -> <APPL>
		fun parse-let = args -> let {
			assert (length args >= 1)
				ERROR::syntax
					"For LET's arity, expected 1 or more, but: " args

			val [body|binds] = args
		in
			binds |> foldr (parse body) { bind body-exp ->
				let {
					assert (bind isa? List andalso length bind == 2)
						ERROR::syntax
							"For LET's binding, expected pair List, but: "
							bind

					val [dvar, dexp] = bind

					assert (var? dvar)
						ERROR::syntax "In LET, expected VAR, but: " dvar
				in
					mk-let (parse dvar, parse dexp, body-exp)
				}
			}
		} where {
			fun mk-let = (dvar, dexp, body) -> EXP::mk-appl (
				EXP::mk-lambda (dvar, body),
				dexp
			)
		}

		#### <Letrec> ####
		# parse-letrec : ['a] -> <LETREC>
		fun parse-letrec = args -> let {
			assert (length args >= 1)
				ERROR::syntax
					"For LETREC's arity, expected 1 or more, but: " args

			val [body|binds] = args
		in
			binds |> foldr (parse body) { bind body-exp ->
				let {
					assert (bind isa? List andalso length bind >= 2)
						ERROR::syntax
							("For LETREC's binding, " ^
								"expected 2 or more List, but: ")
							bind

					val [dvar|dexp] = bind

					assert (var? dvar)
						ERROR::syntax "In LETREC, expected <VAR>, but: " dvar
					assert (form? dexp)
						ERROR::syntax "In LETREC, expected <Form>, but: " dexp

					val [keyword|lam] = dexp

					assert (keyword == @LAMBDA)
						ERROR::syntax
							"In LETREC, expected LAMBDA, but: " keyword
				in
					EXP::mk-letrec (parse dvar, parse-lambda lam, body-exp)
				}
			}
		}
	}
}



######## Interpreter I ########

# interpret-I : <EXP> -> <VAL>
fun interpret-I = r -> eval (r, initenv)
where {

	######## Evaluator ########

	# eval : (<EXP>, <ENV>) -> <VAL>
	fun rec eval = (r, e) -> cond r {

	#### CONST ####
	  EXP::const? -> evcon r
		where
			# evcon : <CONST> -> <INTEGER>
			fun evcon = r -> VAL::mk-integer (val-of r)

	#### VAR ####
	| EXP::var? -> e r

	#### APPL ####
	| EXP::appl? -> let {
		val (opr, opnd) = val-of r

		val va-opr  = eval (opr, e)

		assert (VAL::funval? va-opr)
			ERROR::application
				"In APPL, Expected a <FUNVAL>, but: " va-opr

		val va-opnd = eval (opnd, e)
	in
		(val-of va-opr) va-opnd
	}

	#### LAMBDA ####
	| EXP::lambda? -> evlambda (r, e)

	#### COND ####
	| EXP::cond? -> let {
		val (prem, conc, altr) = val-of r

		val va-prem = eval (prem, e)

		assert (VAL::boolean? va-prem)
			ERROR::type' "In COND, expected a <BOOLEAN>, but: " va-prem
	in
		if (val-of va-prem)
			eval (conc, e)
		else
			eval (altr, e)
	}

	#### LETREC ####
	| EXP::letrec? -> let {
		val (dvar, dexp, body)	= val-of r

		assert (EXP::lambda? dexp)
			ERROR::failure "In LETREC, expected a LAMBDA, but: " r

		# e' : <ENV>
		fun rec e' = x -> if (x == dvar)
								evlambda (dexp, e')
							else
								e x
	in
		eval (body, e')
	}

	#### Other Expression ####
	  else -> ERROR::failure ("Unknown EXP: ", r)

	} where {
		# evlambda : (<LAMBDA>, <ENV>) -> <FUNVAL>
		fun evlambda = (l, e) -> let {
			val (fp, body) = val-of l
		in
			VAL::mk-funval { a -> eval (body, ext (fp, a, e)) }
		} where {
			# ext : (<VAR>, <VAL>, <ENV>) -> <ENV>
			fun ext = (z, a, e) -> {
				x -> if (x == z)
							a
						else
							e x
			}
		}
	}



	######## Environment ########

	# initenv : <ENV>	where { <ENV> = <VAR> -> <VAL> }
	fun initenv = x -> cond (val-of x) {
	#### Constant
	  (== @TRUE)	-> VAL::mk-boolean TRUE
	| (== @FALSE)	-> VAL::mk-boolean FALSE

	#### Number
	| (== @NEG)		-> mk-unop	~     VAL::mk-integer
	| (== @SUCC)	-> mk-unop	(+ 1) VAL::mk-integer
	| (== @PRED)	-> mk-unop	(- 1) VAL::mk-integer
	| (== @ADD)		-> mk-binop	(+)   VAL::mk-integer
	| (== @SUB)		-> mk-binop	(-)   VAL::mk-integer
	| (== @MUL)		-> mk-binop	(*)   VAL::mk-integer
	| (== @DIV)		-> mk-binop	(/)   VAL::mk-integer
	| (== @MOD)		-> mk-binop	(mod) VAL::mk-integer

	#### Relational
	| (== @EQ)		-> mk-binop (==) VAL::mk-boolean
	| (== @LT)		-> mk-binop (<)  VAL::mk-boolean

	  else			-> ERROR::name "Unknown VAR: " x
	} where {
		# int : <VAL> -> Integer
		fun int = x ->
			if (VAL::integer? x)
				val-of x
			else
				ERROR::type' "Expected a Integer, but: " x

		# mk-unop : (Integer -> 'a) -> ('a -> <VAL>) -> <FUNVAL>
		fun mk-unop = unop mk ->
			VAL::mk-funval { x -> unop (int x) |> mk }

		# mk-binop : (Integer -> Integer -> 'a) -> ('a -> <VAL>) -> <FUNVAL>
		fun mk-binop = binop mk ->
			VAL::mk-funval { x ->
				VAL::mk-funval { y -> binop (int x) (int y) |> mk }
			}
	}
}



######## Prelude ########

# Keyword
val IF     = @IF
val LAMBDA = @LAMBDA
val LET    = @LET
val LETREC = @LETREC

# Primitive constant
val T = @TRUE
val F = @FALSE

# Primitive numeric function
val NEG  = @NEG
val SUCC = @SUCC
val PRED = @PRED
val ADD  = @ADD
val SUB  = @SUB
val MUL  = @MUL
val DIV  = @DIV
val MOD  = @MOD

# Primitive relational function
val EQ = @EQ
val LT = @LT

# Built-in logical function
val NOT = [LAMBDA, [@x], [IF, @x, F, T]]

# Built-in relational function
val NE = [LAMBDA, [@x, @y], [NOT, [EQ, @x, @y]]]
val LE = [LAMBDA, [@x, @y], [NOT, [LT, @y, @x]]]
val GT = [LAMBDA, [@x, @y],       [LT, @y, @x]]
val GE = [LAMBDA, [@x, @y], [NOT, [LT, @x, @y]]]



######## Runner - Frontend of Interpreter ########

fun run = interpret ->
	   tee { src -> (puts "<SRC> : " ; p src) }
	>> parse
	>> tee { exp -> (puts "<EXP> : " ; p exp) }
	>> interpret
	>> tee { value -> (puts "-> <VAL> : " ; p value) }

val run-I = run interpret-I



######## Assertion for Test ########

structure ASSERT = struct {
	fun integer = actual expect -> let {
		assert (actual isa? Datum)				"Datum"
		assert (tag-of actual == @Integer)		"@Integer"
		assert (val-of actual isa? Integer)		"Integer"
		assert (val-of actual == expect)		(inspect expect)
	in
		()
	}

	fun true  = actual -> boolean actual TRUE
	fun false = actual -> boolean actual FALSE

	fun funval = actual -> let {
		assert (actual isa? Datum)				"Datum"
		assert (tag-of actual == @Funval)		"@Funval"
		assert (val-of actual isa? Function)	"Function"
	in
		()
	}
} where {
	fun boolean = actual expect -> let {
		assert (actual isa? Datum)				"Datum"
		assert (tag-of actual == @Boolean)		"@Boolean"
		assert (val-of actual isa? Bool)		"Bool"
		assert (val-of actual == expect)		(inspect expect)
	in
		()
	}
}



######## Test ########

fun test = interpret -> (
	print "[CONSTANT]" ;

		#[INPUT] 100
		let {
			val result = run' 100
		in
			ASSERT::integer result 100
		} ;
		#[OUTPUT] -> 100
		nl () ;

		nl () ;

	print "[VARIABLE]" ;

		#[INPUT] TRUE
		let {
			val result = run' T
		in
			ASSERT::true result
		} ;
		#[OUTPUT] -> TRUE
		nl () ;

		#[INPUT] succ
		let {
			val result = run' SUCC
		in
			ASSERT::funval result
		} ;
		#[OUTPUT] -> #<{x -> ... }>
		nl () ;

		nl () ;

	print "[CONDITIONAL]" ;

		#[INPUT] if TRUE then 1 else 2
		let {
			val result = run' [IF, T, 1, 2]
		in
			ASSERT::integer result 1
		} ;
		#[OUTPUT] -> 1
		nl () ;

		#[INPUT] if FALSE then 1 else 2
		let {
			val result = run' [IF, F, 1, 2]
		in
			ASSERT::integer result 2
		} ;
		#[OUTPUT] -> 2
		nl () ;

		nl () ;

	print "[APPLY PRIMITIVE]" ;

		#[INPUT] succ 2
		let {
			val result = run' [SUCC, 2]
		in
			ASSERT::integer result 3
		} ;
		#[OUTPUT] --> 3
		nl () ;

		#[INPUT] succ succ succ 2
		let {
			val result = run' [SUCC, [SUCC, [SUCC, 2]]]
		in
			ASSERT::integer result 5
		} ;
		#[OUTPUT] --> 5
		nl () ;

		#[INPUT] 1 + 2
		let {
			val result = run' [ADD, 1, 2]
		in
			ASSERT::integer result 3
		} ;
		#[OUTPUT] --> 3
		nl () ;

		#[INPUT] 1 = 1
		let {
			val result = run' [EQ, 1, 1]
		in
			ASSERT::true result
		} ;
		#[OUTPUT] --> TRUE
		nl () ;

		nl () ;

	print "[APPLY LAMBDA]" ;

		#[INPUT] (fn x => succ x) 2
		let {
			val result = run' [
				[LAMBDA, [@x], [SUCC, @x]],
				2
			]
		in
			ASSERT::integer result 3
		} ;
		#[OUTPUT] --> 3
		nl () ;

		#[INPUT] (fn x y z => x - y - z) 10 1 2
		let {
			val result = run' [
				[LAMBDA, [@x, @y, @z], [SUB, [SUB, @x, @y], @z]],
				10, 1, 2
			]
		in
			ASSERT::integer result 7
		} ;
		#[OUTPUT] --> 7
		nl () ;

		nl () ;

	print "[LET]" ;

		#[INPUT] let x = 2 in succ x
		let {
			val result = run' [LET, [SUCC, @x], [@x, 2]]
		in
			ASSERT::integer result 3
		} ;
		#[OUTPUT] --> 3
		nl () ;

		#[INPUT]
		#	let x = 2 in
		#	let y = 3 in
		#	x * x + y * y
		let {
			val result = run' [
				LET, [ADD, [MUL, @x, @x], [MUL, @y, @y]],
				[@x, 2],
				[@y, 3]
			]
		in
			ASSERT::integer result 13
		} ;
		#[OUTPUT] --> 13
		nl () ;

		#[INPUT]
		#	let x = 1 in
		#	let y = x in
		#	let x = 2 in
		#	x + y
		let {
			val result = run' [
				LET, [ADD, @x, @y],
				[@x, 1],
				[@y, @x],
				[@x, 2]
			]
		in
			ASSERT::integer result 3
		} ;
		#[OUTPUT] --> 3
		nl () ;

		nl () ;

	print "[LETREC]" ;

		#[INPUT] let f = fn x => succ x in f 2
		let {
			val result = run' [
				LETREC, [@f, 2],
				[@f, LAMBDA, [@x], [SUCC, @x]]
			]
		in
			ASSERT::integer result 3
		} ;
		#[OUTPUT] --> 3
		nl () ;

		#[INPUT]
		#	letrec add = fn x y => x + y in
		#	letrec mul = fn x y => x * y in
		#	add (mul 2 3) (mul 4 5)
		let {
			val result = run' [
				LETREC, [@add, [@mul, 2, 3], [@mul, 4, 5]],
				[@add, LAMBDA, [@x, @y], [ADD, @x, @y]],
				[@mul, LAMBDA, [@x, @y], [MUL, @x, @y]]
			]
		in
			ASSERT::integer result 26
		} ;
		#[OUTPUT] --> 26
		nl () ;

		#[INPUT]
		#	letrec fact = fn x =>
		#       if x <= 1 then 1 else x * fact (x - 1)
		#   in
		#	    fact 4 
		let {
			val result = run' [
				LETREC, [@fact, 4],
				[@fact, LAMBDA, [@x],
					[IF, [LE, @x, 1],
						1,
						[MUL, @x, [@fact, [SUB, @x, 1]]]
					]
				]
			]
		in
			ASSERT::integer result 24
		} ;
		#[OUTPUT] --> 24
		nl () ;

		#[INPUT] 
		#	letrec gcd = fn a b =>
		#       if b == 0 then a else gcd b (a mod b)
		#   in
		#	   gcd 16 28
		let {
			val result = run' [
				LETREC, [@gcd, 16, 28],
				[@gcd, LAMBDA, [@a, @b],
					[IF, [EQ, @b, 0],
						@a,
						[@gcd, @b, [MOD, @a, @b]]
					]
				]
			]
		in
			ASSERT::integer result 4
		} ;
		#[OUTPUT] --> 4
		nl () ;

		nl ()
) where {
	val run' = run interpret
}

;;

test interpret-I ;;

(#
 Implementation of REYNOLDS's Definional Interpretor

 Reynolds, J. C. :
   Definitional Interpretors
   for Higher-Oreder Programming Languages,
   Higer-Order and Symbolic Computation, 11, 363-397 (1998),
   Proceedings of 25h ACM National Conference, 1971, pp. 717-740

 木村泉, 米澤明憲 :
   第9章 算法表現(プログラム)の意味論,
   算法表現論, 岩波講座情報科学12, 岩波書店, 1982

	   上記論文のInterpreter I と II を元にして、
	   古典的な操作的意味論を解説
#)



######## Error ########

module ERROR = struct {
	# failure : (String, 'a) -> ()
	fun failure		= (msg, x) -> error ("Assertion Failure",	msg, x)

	# syntax : (String, 'a) -> ()
	fun syntax		= (msg, x) -> error ("Syntax Error",		msg, x)

	# name : (String, 'a) -> ()
	fun name		= (msg, x) -> error ("Name Error",			msg, x)

	# application : (String, 'a) -> ()
	fun application	= (msg, x) -> error ("Application Error",	msg, x)

	# type' : (String, 'a) -> ()
	fun type'		= (msg, x) -> error ("Type Error",			msg, x)
} where {
	fun error = (category, msg, x) ->
		abort ("[" ^ category ^ "] " ^ msg ^ inspect x)
}



(######## Expression ########

<EXP> = <CONST> + <VAR> + <APPL> + <LAMBDA> + <COND> + <LETREC>

<APPL>   = [opr: <EXP>, opnd: <EXP>]
<LAMBDA> = [fp: <VAR>, body: <EXP>]
<COND>   = [prem: <EXP>, conc: <EXP>, altr: <EXP>]
<LETREC> = [dvar: <VAR>, dexp: <LAMBDA>, body: <EXP>]

############################)

module EXP = struct {
	#### Constructor ####

	# mk-const : Int -> <CONST>
	fun mk-const = x -> DATUM::make @Const x

	# mk-var : Symbol -> <VAR>
	fun mk-var = x -> DATUM::make @Var x

	# mk-appl : (<EXP>, <EXP>) -> <APPL>
	fun mk-appl = (opr, opnd) -> DATUM::make @Appl (opr, opnd)

	# mk-lambda : (<VAR>, <EXP>) -> <LAMBDA>
	fun mk-lambda = (fp, body) -> DATUM::make @Lambda (fp, body)

	# mk-cond : (<EXP>, <EXP>, <EXP>) -> <COND>
	fun mk-cond = (prem, conc, altr) ->
		DATUM::make @Cond (prem, conc, altr)

	# mk-letrec : (<VAR>, <LAMBDA>, <EXP>) -> <LETREC>
	fun mk-letrec = (dvar, dexp, body) ->
		DATUM::make @Letrec (dvar, dexp, body)


	#### Classifier ####

	# const? : <EXP> -> Bool
	fun const? = exp -> DATUM::tag exp == @Const

	# var? : <EXP> -> Bool
	fun var? = exp -> DATUM::tag exp == @Var

	# appl? : <EXP> -> Bool
	fun appl? = exp -> DATUM::tag exp == @Appl

	# lambda? : <EXP> -> Bool
	fun lambda? = exp -> DATUM::tag exp == @Lambda

	# cond? : <EXP> -> Bool
	fun cond? = exp -> DATUM::tag exp == @Cond

	# letrec? : <EXP> -> Bool
	fun letrec? = exp -> DATUM::tag exp == @Letrec
} where {
	module DATUM = UMU::DATUM
}



(######## Value ########

<VAL> = <INTEGER> + <BOOLEAN> + <FUNVAL>

################)

module VAL = struct {
	#### Constructor ####

	# Int -> <INTEGER>
	fun mk-integer = x -> DATUM::make @Integer x

	# Bool -> <BOOLEAN>
	fun mk-boolean = x -> DATUM::make @Boolean x

	# Function -> <FUNVAL>
	fun mk-funval = x -> DATUM::make @Funval x


	#### Classifier ####

	# <VAL> -> Bool
	fun integer? = exp -> DATUM::tag exp == @Integer

	# <VAL> -> Bool
	fun boolean? = exp -> DATUM::tag exp == @Boolean

	# <VAL> -> Bool
	fun funval?	 = exp -> DATUM::tag exp == @Funval
} where {
	module DATUM = UMU::DATUM
}



(######## Parser ########

 <Exp> ::= <Const>	/* Undefined, Umu's Int */
         | <Var>	/* Undefined, Umu's Symbol */
		 | <Form>


 <Form> ::= <If> | <Lambda> | <Apply> | <Let> | <Letrec>



 <If>     ::= "[" IF "," <Exp> "," <Exp> "," <Exp> "]"


 <Lambda> ::= "[" LAMBDA "," "[" <Var1> "," ... "," <VarN> "]" "," <Exp> "]"
 																/* N >= 1 */

 <Apply>  ::= "[" <Exp1> "," ... "," <ExpN> "]"  /* N >= 2 */


 <Let>    ::= "[" LET "," <Exp> "," <ValBind1> "," ... "," <ValBindN> "]"
 <ValBind> ::= "[" <Var> "," <Exp> "]"							/* N >= 0 */


 <Letrec> ::= "[" LETREC "," <Exp> "," <LamBind1> "," ... "," <LamBindN> "]"
 <LamBind> ::= "[" <Var> "|" <Lambda> "]"						/* N >= 0 */

########################)

# parse : 'a -> <EXP>
fun rec parse = exp -> cond exp {
  const?	-> EXP::mk-const exp
| var?		-> EXP::mk-var exp
| form?		-> parse-form exp
  else		-> ERROR::syntax ("Unknown Expression: ", exp)
} where {
	# const? : 'a -> Bool
	fun const? = exp -> exp isa? Int

	# var? : 'a -> Bool
	fun var? = exp -> exp isa? Symbol

	# form? : 'a -> Bool
	fun form? = exp -> exp isa? List andalso length exp >= 2


	#### <Form> ####
	# parse-form : ['a] -> <EXP>
	fun parse-form = exp ->
		if (keyword isa? Symbol)
			cond keyword {
			  (== @IF)		-> parse-if		args
			| (== @LAMBDA)	-> parse-lambda	args
			| (== @LET)		-> parse-let	args
			| (== @LETREC)	-> parse-letrec	args
			  else			-> parse-apply	exp
			}
		else
			parse-apply	exp
	where {
		val [keyword|args] = exp

		#### <If> ####
		# parse-if : ['a] -> <COND>
		fun parse-if = args ->
			EXP::mk-cond (parse prem, parse conc, parse altr)
		where {
			val _ = unless (length args == 3)
						ERROR::syntax (
							"For IF's arity, expected 3, but: ",
							args
						)
			val [prem, conc, altr] = args
		}

		#### <Lambda> ####
		# parse-lambda : ['a] -> <LAMBDA>
		fun parse-lambda = args ->
			fps' |> fold init-body-exp { fp body-exp ->
					EXP::mk-lambda (parse fp, body-exp)
			where val _ = unless (var? fp)
							ERROR::syntax (
								"In LAMBDA, expected a VAR, but: ",
								fp
							)
			}
		where {
			val _ = unless (length args == 2)
						ERROR::syntax (
							"For LAMBDA's arity, expected 2, but: ",
							args
						)
			val [fps, body] = args
			val _ = unless (fps isa? List)
						ERROR::syntax (
							"In LAMBDA, expected a List of VAR, but: ",
							fps
						)
			val _ = unless (length fps >= 1)
						ERROR::syntax (
							"In LAMBDA, " ^
								"expected length of VARs is " ^
								"1 or more, but: ",
							fps
						)
			val [init-fp|fps'] = reverse fps
			val init-body-exp = EXP::mk-lambda (parse init-fp, parse body)
				where { val _ = unless (var? init-fp)
								ERROR::syntax (
									"In LAMBDA, expected a VAR, but: ",
									init-fp
								)
				}
			}

		#### <Apply> ####
		# parse-apply : ['a] -> <APPL>
		fun parse-apply = form ->
			opnds |> fold init-opr-exp { opnd opr-exp ->
				EXP::mk-appl (opr-exp, parse opnd)
			}
		where {
			val [opr, init-opnd|opnds] = form
			val init-opr-exp = EXP::mk-appl (parse opr, parse init-opnd)
		}

		#### <Let> ####
		# parse-let : ['a] -> <APPL>
		fun parse-let = args ->
			binds |> foldr (parse body) { bind body-exp ->
				mk-let (parse dvar, parse dexp, body-exp)
			where
				val _ = unless (bind isa? List andalso length bind == 2)
							ERROR::syntax (
								"For LET's binding, " ^
								"expected pair List, but: ",
								bind
							)
				val [dvar, dexp] = bind
				val _ = unless (var? dvar)
							ERROR::syntax (
								"In LET, expected VAR, but: ",
								dvar
							) 
			}
		where {
			val _ = unless (length args >= 1)
						ERROR::syntax (
							"For LET's arity, expected 1 or more, but: ",
							args
						)
			val [body|binds] = args

			fun mk-let = (dvar, dexp, body) -> EXP::mk-appl (
				EXP::mk-lambda (dvar, body),
				dexp
			)
		}

		#### <Letrec> ####
		# parse-letrec : ['a] -> <LETREC>
		fun parse-letrec = args ->
			binds |> foldr (parse body) { bind body-exp ->
				EXP::mk-letrec (parse dvar, parse-lambda lam, body-exp)
			where
				val _ = unless (bind isa? List andalso length bind >= 2)
							ERROR::syntax (
								"For LETREC's binding, " ^
								"expected 2 or more List, but: ",
								bind
							)
				val [dvar|dexp] = bind
				val _ = unless (var? dvar)
							ERROR::syntax (
								"In LETREC, expected VAR, but: ",
								dvar
							) 
				val _ = unless (form? dexp)
							ERROR::syntax (
								"In LETREC, expected <Form>, but: ",
								dexp
							) 
				val [keyword|lam] = dexp
				val _ = unless (keyword == @LAMBDA)
							ERROR::syntax (
								"In LETREC, expected LAMBDA, but: ",
								keyword
							) 
			}
		where {
			val _ = unless (length args >= 1)
						ERROR::syntax (
							"For LETREC's arity, expected 1 or more, but: ",
							args
						)
			val [body|binds] = args
		}
	}
}



######## Interpreter I ########

# interpret-I : <EXP> -> <VAL>
fun interpret-I = r -> eval (r, initenv)
where {

	######## Evaluator ########

	# eval : (<EXP>, <ENV>) -> <VAL>
	fun rec eval = (r, e) -> cond r {

	#### CONST ####
	  EXP::const? -> evcon r
		where
			# evcon : CONST -> INTEGER
			fun evcon = r -> VAL::mk-integer (val-of r)

	#### VAR ####
	| EXP::var? -> e r

	#### APPL ####
	| EXP::appl? -> (val-of va-opr) va-opnd
		where
			val (opr, opnd) = val-of r

			val va-opr  = eval (opr, e)
			val _ = unless (VAL::funval? va-opr)
						ERROR::application (
							"In APPL, Expected a FUNVAL, but: ",
							va-opr
						)
			val va-opnd = eval (opnd, e)

	#### LAMBDA ####
	| EXP::lambda? -> evlambda (r, e)

	#### COND ####
	| EXP::cond? -> if (val-of va-prem)
						eval (conc, e)
					else
						eval (altr, e)
		where
			val (prem, conc, altr) = val-of r

			val va-prem = eval (prem, e)
			val _ = unless (VAL::boolean? va-prem)
						ERROR::type' (
							"In COND, expected a BOOLEAN, but: ",
							va-prem
						)

	#### LETREC ####
	| EXP::letrec? -> eval (body, e')
		where
			val (dvar, dexp, body)	= val-of r

			val _ = unless (EXP::lambda? dexp)
						ERROR::failure (
							"In LETREC, expected a LAMBDA, but: ",
							r
						)

			# e' : <ENV>
			fun rec e' = x -> if (x == dvar)
									evlambda (dexp, e')
								else
									e x

	  else -> ERROR::failure ("Unknown EXP: ", r)

	} where {
		# evlambda : (<LAMBDA>, <ENV>) -> <FUNVAL>
		fun evlambda = (l, e) -> VAL::mk-funval {
										a -> eval (body, ext (fp, a, e))
									}
		where {
			val (fp, body) = val-of l

			# ext : (<VAR>, <VAL>, <ENV>) -> <ENV>
			fun ext = (z, a, e) -> {
				x -> if (x == z)
							a
						else
							e x
			}
		}
	}



	######## Environment ########

	# initenv : <ENV>	where { <ENV> = <VAR> -> <VAL> }
	fun initenv = x -> cond (val-of x) {
	#### Constant
	  (== @TRUE)	-> VAL::mk-boolean TRUE
	| (== @FALSE)	-> VAL::mk-boolean FALSE

	#### Number
	| (== @NEG)		-> mk-unop	~     VAL::mk-integer
	| (== @SUCC)	-> mk-unop	(+ 1) VAL::mk-integer
	| (== @PRED)	-> mk-unop	(- 1) VAL::mk-integer
	| (== @ADD)		-> mk-binop	(+)   VAL::mk-integer
	| (== @SUB)		-> mk-binop	(-)   VAL::mk-integer
	| (== @MUL)		-> mk-binop	(*)   VAL::mk-integer
	| (== @DIV)		-> mk-binop	(/)   VAL::mk-integer
	| (== @MOD)		-> mk-binop	(mod) VAL::mk-integer

	#### Relational
	| (== @EQ)		-> mk-binop (==) VAL::mk-boolean
	| (== @LT)		-> mk-binop (<)  VAL::mk-boolean

	  else			-> ERROR::name ("Unknown VAR: ", x)
	} where {
		# int : <VAL> -> Int
		fun int = x ->
			if (VAL::integer? x)
				val-of x
			else
				ERROR::type' ("Expected a Int, but: ", x)

		# mk-unop : (Int -> 'a) -> ('a -> <VAL>) -> <FUNVAL>
		fun mk-unop = unop mk ->
			VAL::mk-funval { x -> unop (int x) |> mk }

		# mk-binop : (Int -> Int -> 'a) -> ('a -> <VAL>) -> <FUNVAL>
		fun mk-binop = binop mk ->
			VAL::mk-funval { x ->
				VAL::mk-funval { y -> binop (int x) (int y) |> mk }
			}
	}
}



######## Prelude ########

# Keyword
val IF     = @IF
val LAMBDA = @LAMBDA
val LET    = @LET
val LETREC = @LETREC

# Primitive constant
val T = @TRUE
val F = @FALSE

# Primitive numeric function
val NEG  = @NEG
val SUCC = @SUCC
val PRED = @PRED
val ADD  = @ADD
val SUB  = @SUB
val MUL  = @MUL
val DIV  = @DIV
val MOD  = @MOD

# Primitive relational function
val EQ = @EQ
val LT = @LT

# Built-in logical function
val NOT = [LAMBDA, [@x], [IF, @x, F, T]]

# Built-in relational function
val NE = [LAMBDA, [@x, @y], [NOT, [EQ, @x, @y]]]
val LE = [LAMBDA, [@x, @y], [NOT, [LT, @y, @x]]]
val GT = [LAMBDA, [@x, @y],       [LT, @y, @x]]
val GE = [LAMBDA, [@x, @y], [NOT, [LT, @x, @y]]]



######## Example Runner ########

fun example-run = interpret -> (
	  print "[CONSTANT]" ;

		#[INPUT] 100
		run 100 ;
		#[OUTPUT] -> 100

		nl ()

	; print "[VARIABLE]" ;

		#[INPUT] TRUE
		run T ;
		#[OUTPUT] -> TRUE

		#[INPUT] succ
		run SUCC ;
		#[OUTPUT] -> #<fn x -> ...>

		nl ()

	; print "[CONDITIONAL]" ;

		#[INPUT] if TRUE then 1 else 2
		run [IF, T, 1, 2] ;
		#[OUTPUT] -> 1

		#[INPUT] if FALSE then 1 else 2
		run [IF, F, 1, 2] ;
		#[OUTPUT] -> 2

		nl ()

	; print "[APPLY PRIMITIVE]" ;

		#[INPUT] succ 2
		run [SUCC, 2] ;
		#[OUTPUT] --> 3

		#[INPUT] succ succ succ 2
		run [SUCC, [SUCC, [SUCC, 2]]] ;
		#[OUTPUT] --> 5

		#[INPUT] 1 + 2
		run [ADD, 1, 2] ;
		#[OUTPUT] --> 3

		#[INPUT] 1 = 1
		run [EQ, 1, 1] ;
		#[OUTPUT] --> TRUE

		nl ()

	; print "[APPLY LAMBDA]" ;

		#[INPUT] (fn x => succ x) 2
		run [
			[LAMBDA, [@x], [SUCC, @x]],
			2
		] ;
		#[OUTPUT] --> 3

		#[INPUT] (fn x y z => x - y - z) 10 1 2
		run [
			[LAMBDA, [@x, @y, @z], [SUB, [SUB, @x, @y], @z]],
			10, 1, 2
		] ;
		#[OUTPUT] --> 7

		nl ()

	; print "[LET]" ;

		#[INPUT] { succ 1 where }
		run [LET, [SUCC, 1]] ;
		#[OUTPUT] --> 2

		#[INPUT] { succ x where x = 2 }
		run [LET, [SUCC, @x],
			[@x, 2]
		] ;
		#[OUTPUT] --> 3

		#[INPUT] { x * x + y * y where x = 2, y = 3 }
		run [LET, [ADD, [MUL, @x, @x], [MUL, @y, @y]],
			[@x, 2],
			[@y, 3]
		] ;
		#[OUTPUT] --> 13

		#[INPUT] {{ x + y where y = x, x = 2 } where x = 1 }
		run [LET,
			[LET, [ADD, @x, @y],
				[@y, @x],
				[@x, 2]
			],
			[@x, 1]
		] ;
		#[OUTPUT] --> 3

		nl ()

	; print "[LETREC]" ;

		#[INPUT] { succ 1 whererec }
		run [LETREC, [SUCC, 1]] ;
		#[OUTPUT] --> 2

		#[INPUT] { f 2 whererec f = fn x => succ x }
		run [LETREC, [@f, 2], [@f, LAMBDA, [@x], [SUCC, @x]]] ;
		#[OUTPUT] --> 3

		#[INPUT] { add (mul 2 3) (mul 4 5)
		#			whererec
		#				add = fn x y => x + y,
		#				mul = fn x y => x * y
		#		 }
		run [LETREC, [@add, [@mul, 2, 3], [@mul, 4, 5]],
			[@add, LAMBDA, [@x, @y], [ADD, @x, @y]],
			[@mul, LAMBDA, [@x, @y], [MUL, @x, @y]]
		] ;
		#[OUTPUT] --> 26

		#[INPUT] { fact 4 
		#			whererec
		#				fact = x -> if x <= 1 then 1 else x * fact (x - 1)
		#		 }
		run [LETREC, [@fact, 4],
			[@fact, LAMBDA, [@x],
				[IF, [LE, @x, 1],
					1,
					[MUL, @x, [@fact, [SUB, @x, 1]]]
				]
			]
		] ;
		#[OUTPUT] --> 24

		#[INPUT] { gcd 16 28
		#			whererec
		#				gcd = a b -> if b = 0 then a else gcd b (a mod b)
		#		 }
		run [LETREC, [@gcd, 16, 28],
			[@gcd, LAMBDA, [@a, @b],
				[IF, [EQ, @b, 0],
					@a,
					[@gcd, @b, [MOD, @a, @b]]
				]
			]
		] ;
		#[OUTPUT] --> 4

		nl ()


) where {
	val run = parse >> interpret >> p
}

;;



# Example Runs

example-run interpret-I ;;
